{"meta":{"title":"无邪の博客","subtitle":"","description":"个人博客，记录学习和生活","author":"AmazingDL","url":"https://amazingdl.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-10-01T02:41:21.174Z","updated":"2020-10-01T02:41:21.174Z","comments":false,"path":"categories/index.html","permalink":"https://amazingdl.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-10-13T00:15:02.867Z","updated":"2020-10-01T02:41:21.175Z","comments":false,"path":"repository/index.html","permalink":"https://amazingdl.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-01T02:41:21.176Z","updated":"2020-10-01T02:41:21.176Z","comments":false,"path":"tags/index.html","permalink":"https://amazingdl.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2020-10-13T00:15:11.954Z","updated":"2020-10-01T02:41:21.172Z","comments":false,"path":"/404.html","permalink":"https://amazingdl.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-01T02:41:21.173Z","updated":"2020-10-01T02:41:21.173Z","comments":false,"path":"about/index.html","permalink":"https://amazingdl.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-10-01T02:41:21.174Z","updated":"2020-10-01T02:41:21.174Z","comments":false,"path":"books/index.html","permalink":"https://amazingdl.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-10-01T02:41:21.175Z","updated":"2020-10-01T02:41:21.175Z","comments":true,"path":"links/index.html","permalink":"https://amazingdl.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"MyBatis的简单使用","slug":"技术杂谈/MyBatis/MyBatis","date":"2020-11-12T12:30:25.000Z","updated":"2020-11-15T02:32:44.127Z","comments":true,"path":"2020/11/12/技术杂谈/MyBatis/MyBatis/","link":"","permalink":"https://amazingdl.github.io/2020/11/12/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/MyBatis/MyBatis/","excerpt":"什么是框架？什么优势ORM框架？MyBatis就是一个很好的例子，从基本的增删改查到复杂的结果映射处理，都是MyBatis提供给我们强大的功能。","text":"一、Mybatis框架概述1.1 概述ORM：将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作。 因此ORM的目的是为了方便开发人员以面向对象的思想来实现对数据库的操作。 ORM 采用元数据来描述对象-关系映射细节： 元数据通常采用 XML 格式，并且存放在专门的对象-关系映射文件中。 MyBatis就一个持久层框架ORM，用于程序与数据库之间的交互。 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 在进行web开发时，通常会通过Spring整合MyBatis，所以MyBatis就全权交给Spring管理。 1.2 持久化持久化是将程序数据在持久状态和瞬时状态间转换的机制。 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。 为什么需要持久化服务呢？那是由于内存本身的缺陷引起的 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。 1.3 持久层什么是持久层？ 完成持久化工作的代码块 . —-&gt; dao层 【DAO (Data Access Object) 数据访问对象】 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界 1.4 MyBatis特点 Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 . 传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 . MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) –&gt;对象关系映射 所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分，只有使用这个技术的人有高低之别 MyBatis的优点 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供xml标签，支持编写动态sql。 1.5 相关环境依赖 1234567891011121314151617181920&lt;!-- myBatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- MySQL链接包 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt; 数据库 123456789101112CREATE TABLE `phone` ( `id` int(0) NOT NULL AUTO_INCREMENT, `value` int(0) NOT NULL, `name` varchar(20) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE = InnoDB default charset = utf8;INSERT INTO `phone` VALUES (1, 3999, &#x27;一加八&#x27;);INSERT INTO `phone` VALUES (2, 5999, &#x27;华为p40&#x27;);INSERT INTO `phone` VALUES (3, 3699, &#x27;小米10&#x27;);INSERT INTO `phone` VALUES (4, 3899, &#x27;魅族17&#x27;);INSERT INTO `phone` VALUES (5, 5999, &#x27;三星s20&#x27;); 二、JDBC案例实体类 12345678910111213141516171819202122232425public class Phone &#123; private Integer id;//编号 private Integer value;//价格 private String name;//名称 public Phone(Integer id, Integer value, String name) &#123; this.id = id; this.value = value; this.name = name; &#125; public Phone() &#123; &#125; //get和set方法 @Override public String toString() &#123; return &quot;Phone&#123;&quot; + &quot;id=&quot; + id + &quot;, value=&quot; + value + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args) throws SQLException &#123; Connection connection=null; PreparedStatement stmt=null; ResultSet result=null; String username=&quot;root&quot;; String password=&quot;134679dinglei&quot;; String url=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot;; try &#123; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);//加载驱动类，并抛出异常 //获取链接 connection= DriverManager.getConnection(url,username,password); String sql=&quot;select * from phone where id=?&quot;; //执行SQL语句 stmt=connection.prepareStatement(sql); //填充占位符，第一个参数是表示第几个占位符，第二个参数表示填充的值 stmt.setInt(1,2); //获取结果集 result=stmt.executeQuery(); Phone phone=null; //遍历结构集 while (result.next())&#123; phone=new Phone(result.getInt(&quot;id&quot;),result.getInt(&quot;value&quot;) ,result.getString(&quot;name&quot;)); &#125; System.out.println(phone); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭连接，ResultSet-&gt;PreparedStatement-&gt;Connection if(result!=null)&#123; result.close(); &#125; if(stmt!=null)&#123; stmt.close(); &#125; if(connection!=null)&#123; connection.close();; &#125; &#125; &#125; 三、自定义框架3.1 概述 3.2 Configuration类123456789101112131415161718192021222324252627282930313233343536/** * 自定义配置文件对象 */public class Configuration &#123; private String driver;//驱动类 private String url;//链接地址 private String username;//用户名 private String password;//密码 /** * 封装Mapper的每个SQL语句 * Map集合键，通过namespace+&quot;.&quot;+id 锁定唯一SQL语句 * Map集合值，Mapper对象，封装结果集pojo和SQL语句 */ private Map&lt;String,Mapper&gt; map = new HashMap&lt;String, Mapper&gt;(); public Map&lt;String, Mapper&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Mapper&gt; map) &#123; this.map = map; &#125; //get、set方法 @Override public String toString() &#123; return &quot;Configuration&#123;&quot; + &quot;driver=&#x27;&quot; + driver + &#x27;\\&#x27;&#x27; + &quot;, url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 3.3 Mapper类1234567891011121314151617/** * 自定义映射文件对象 */public class Mapper &#123; private String sql;//sql语句 private String resultType;//返回值类型 //get、set方法 @Override public String toString() &#123; return &quot;Mapper&#123;&quot; + &quot;sql=&#x27;&quot; + sql + &#x27;\\&#x27;&#x27; + &quot;, resultType=&#x27;&quot; + resultType + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 3.4 SqlSession类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * JDBC的操作，框架中是必须的 */public class SqlSession &#123; //xml配置文件对象 private Configuration configuration ; public void setConfiguration(Configuration configuration) &#123; this.configuration = configuration; &#125; public &lt;T&gt; List&lt;T&gt; selectList(String sqlId) throws Exception &#123; //创建返回结果对象 List&lt;T&gt; list = new ArrayList&lt;T&gt;(); //通过配置对象的属性加载驱动类 Class.forName(configuration.getDriver()); //获取连接 Connection con = DriverManager.getConnection(configuration.getUrl(),configuration.getUsername(),configuration.getPassword()); // 配置文件对象，获取唯一SQL语句 String sql = configuration.getMap().get(sqlId).getSql(); PreparedStatement pst = con.prepareStatement(sql); ResultSet rs = pst.executeQuery(); //从结果集中获取元数据 ResultSetMetaData metaData = rs.getMetaData(); //集合存储列名 List&lt;String&gt; cloumnNameList = new ArrayList&lt;String&gt;(); for(int i = 1 ; i &lt;= metaData.getColumnCount(); i++)&#123; cloumnNameList.add(metaData.getColumnName(i)); &#125; Object obj = null; //配置文件，获取结果集封装的pojo对象的全限定名 String resultType = configuration.getMap().get(sqlId).getResultType(); Class clazz = Class.forName(resultType); //反射获取方法 Method[] methods = clazz.getDeclaredMethods(); while (rs.next())&#123; //反射创建对象 obj = clazz.newInstance(); //遍历集合，获取列名 for(String columnName : cloumnNameList)&#123; Object columnValue = rs.getObject(columnName); System.out.println(columnValue); //遍历方法数组 for(Method method : methods)&#123; //取出方法名字 String methodName = method.getName(); //判断列名是否与 set+方法名字相同 if(methodName.equalsIgnoreCase(&quot;set&quot;+columnName))&#123; //反射调用set方法，存储列值 method.invoke(obj,columnValue); &#125; &#125; &#125; //对象存储集合 list.add((T) obj); &#125; return list; &#125;&#125; 3.5 SqlSessionFactory类123456789101112131415public class SqlSessionFactory &#123; private Configuration configuration; /** * 返回SqlSession接口实现类对象 */ public SqlSessionImpl openSession()&#123; SqlSessionImpl sqlSession = new SqlSessionImpl(); sqlSession.setConfiguration(configuration); return sqlSession; &#125; public void setConfiguration(Configuration configuration) &#123; this.configuration = configuration; &#125;&#125; 3.6 SqlSessionFactoryBuilder类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/** * 自定义SqlSessionFactory工厂构建者 */public class SqlSessionFactoryBuilder &#123; /** * 返回SqlSessionFactory工厂对象 * 接收字节输入流 * 用户传递流 */ public SqlSessionFactory builder(InputStream inputStream)&#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactory(); //获取配置文件对象 Configuration configuration = loadXmlConfig(inputStream); //configuration传递到SqlSessionFactory工厂 sqlSessionFactory.setConfiguration(configuration); return sqlSessionFactory; &#125; /** * 加载全局配置文件，并封装到MyBatis的配置类中并返回 * @param inputStream xml文件输入流 * @return */ public Configuration loadXmlConfig(InputStream inputStream)&#123; Configuration configuration = new Configuration(); SAXReader saxReader = new SAXReader(); try &#123; //将输入流封装为一个文档对象 Document document = saxReader.read(inputStream); //获取根节点 Element rootElement = document.getRootElement(); // xpath表达式，解析property List&lt;Element&gt; list = rootElement.selectNodes(&quot;//property&quot;); if(list!=null &amp;&amp; list.size()&gt;0)&#123; //遍历集合 for(Element element : list)&#123; //属性值 String name = element.attributeValue(&quot;name&quot;); String value = element.attributeValue(&quot;value&quot;); //判断name属性值，进行configuration对象封装 if(&quot;driver&quot;.equalsIgnoreCase(name)) configuration.setDriver(value); else if (&quot;url&quot;.equalsIgnoreCase(name)) configuration.setUrl(value); else if (&quot;username&quot;.equalsIgnoreCase(name)) configuration.setUsername(value); else if (&quot;password&quot;.equalsIgnoreCase(name)) configuration.setPassword(value); &#125; &#125; //解析mapper标签，并遍历 List&lt;Element&gt; mapperList = rootElement.selectNodes(&quot;//mapper&quot;); if(mapperList!=null &amp;&amp; mapperList.size()&gt;0)&#123; for(Element mapper : mapperList)&#123; //获取xml文件路径 String mapperPath = mapper.attributeValue(&quot;resource&quot;); loadSqlConfig(mapperPath,configuration); &#125; &#125; &#125; catch (DocumentException e)&#123; e.printStackTrace(); &#125; return configuration; &#125; /** * 加载Mapper配置文件内容，并封装到配置对象的map中 * @param mapperPath mapper映射文件路径 * @param configuration 配置对象 */ public void loadSqlConfig(String mapperPath,Configuration configuration)&#123; InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(mapperPath); SAXReader saxReader = new SAXReader(); Document document = null; try &#123; document = saxReader.read(inputStream); Element rootElement = document.getRootElement(); //根标签namespace属性 String namespace = rootElement.attributeValue(&quot;namespace&quot;); List&lt;Element&gt; selectList = rootElement.selectNodes(&quot;//select&quot;); if(selectList!=null &amp;&amp; selectList.size()&gt;0)&#123; for(Element element : selectList)&#123; //标签体，获取SQL语句 String sql = element.getText(); //属性resultType获取pojo对象 String resultType = element.attributeValue(&quot;resultType&quot;); //select标签id属性 String id = element.attributeValue(&quot;id&quot;); Mapper mapper = new Mapper(); //封装Mapper对象 mapper.setSql(sql); mapper.setResultType(resultType); //封装配置文件对象 //根标签namespace属性值+.+id属性值 configuration.getMap().put(namespace+&quot;.&quot;+id,mapper); &#125; &#125; &#125; catch (DocumentException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.7 mybatis-config配置文件12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true&amp;amp;useSSL=false&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;134679dinglei&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;test/PhoneMapper.xml&quot;&gt; &lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3.8 phoneMapper配置文件123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;queryPhoneList&quot; resultType=&quot;com.wuxie.mybatis.entity.Phone&quot;&gt; select * from phone &lt;/select&gt;&lt;/mapper&gt; 3.9 测试1234567891011121314public class Test &#123; public static void main(String[] args) throws Exception &#123; InputStream inputStream = Resources.getResourceAsStream(&quot;test\\\\mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;Phone&gt; list = sqlSession.selectList(&quot;test.queryPhoneList&quot;); if(list!=null &amp;&amp; list.size()&gt;0)&#123; for(Phone user : list)&#123; System.out.println(user); &#125; &#125; &#125;&#125; 四、MyBatis入门案例①全局配置文件 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 配置MyBatis环境 --&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;amp;useUnicode=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;134679dinglei&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; ②Mapper映射文件 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.wuxie.mybatis.dao.UserMapper&quot;&gt; &lt;select id=&quot;queryAllUser&quot; resultType=&quot;com.wuxie.mybatis.entity.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; ③Mapper接口 12345public interface UserMapper &#123; List&lt;User&gt; queryAllUser();&#125; ④测试 1234567891011121314151617181920212223public static void main(String[] args) throws IOException &#123; //1.加载MyBatis-config.xml全局配置文件 String location = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(location); //2.通过配置文件创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //3.通过SqlSessionFactory获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //4.通过SqlSession对象获取对应的Mapper对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //5.通过Mapper对象实现对数据库的操作 List&lt;User&gt; users = userMapper.queryAllUser(); for(User user:users)&#123; System.out.println(user.toString()); &#125; //6.关闭SqlSession对象 sqlSession.close();&#125; 五、MyBatis中的增删改查5.1 Select标签5.1.1 标签常见属性 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句，与对应的Mapper接口中的方法名一致。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 resultType 期望从这条语句中返回结果的类全限定名或别名。，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。resultType 和 resultMap 之间只能同时使用一个。 resultMap 对外部 resultMap 的命名引用。结果映射是 MyBatis最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。resultType 和 resultMap 之间只能同时使用一个。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。 useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement(调用存储过程与函数)，默认值：PREPARED。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。 5.1.2 查询单个结果集①Mapper接口 123public interface UserMapper &#123; User queryUserById(Integer id);&#125; ②Mapper映射文件 123&lt;select id=&quot;queryUserById&quot; resultType=&quot;com.wuxie.mybatis.entity.User&quot;&gt; select * from user where id=#&#123;id&#125;&lt;/select&gt; ③测试 123456789SqlSession sqlSession = MyBatisUtil.getSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);User user = mapper.queryUserById(1);System.out.println(user.toString());sqlSession.close(); 5.1.3 查询多个结果集①Mapper映射文件 123&lt;select id=&quot;queryAllUser&quot; resultType=&quot;com.wuxie.mybatis.entity.User&quot;&gt; select * from user&lt;/select&gt; ②Mapper接口 12345public interface UserMapper &#123; List&lt;User&gt; queryAllUser();&#125; ③测试 123456789101112SqlSession sqlSession = MyBatisUtil.getSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);//如果查询的结果为多个类型为resultType的对象，那么MyBatis会自动封装到list集合中List&lt;User&gt; users = mapper.queryAllUser();for(User user:users)&#123; System.out.println(user.toString());&#125;sqlSession.close(); 5.2 增删改5.2.1 标签常见属性 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句，同样与Mapper接口的方法名相同。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 keyColumn （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。 5.2.2 测试注意：增、删、改操作需要提交事务 mapper配置文件 1234567891011121314&lt;insert id=&quot;addUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; parameterType=&quot;com.wuxie.mybatis.entity.User&quot;&gt; insert into user(name,gender,age) values(#&#123;name&#125;,#&#123;gender&#125;,#&#123;age&#125;)&lt;/insert&gt;&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.wuxie.mybatis.entity.User&quot;&gt; update user set name=#&#123;name&#125;,gender=#&#123;gender&#125;,age=#&#123;age&#125; where id=#&#123;id&#125;&lt;/update&gt;&lt;delete id=&quot;deleteUserById&quot;&gt; delete from user where id=#&#123;id&#125;&lt;/delete&gt; mappper接口 123456789public interface UserMapper &#123; int addUser(User user); int updateUser(User user); int deleteUserById(Integer id);&#125; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class NoSelectTest &#123; public static void main(String[] args) &#123; //testInsert(); //testUpdate(); testDelete(); &#125; public static void testDelete()&#123; SqlSession sqlSession = MyBatisUtil.getSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int result = userMapper.deleteUserById(2); System.out.println(result); sqlSession.commit(); sqlSession.close(); &#125; public static void testUpdate()&#123; User user = new User(); user.setId(3); user.setName(&quot;李世民&quot;); user.setAge(40); user.setGender(&quot;男&quot;); SqlSession sqlSession = MyBatisUtil.getSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int result = userMapper.updateUser(user); System.out.println(result); sqlSession.commit(); sqlSession.close(); &#125;&#125; 5.3 传递多个参数当SQL语句需要传递多个参数时，又不至于封装到一个实体类对象时，可将多个参数以键值对的方式存入map中，然后将map作为参数传递给SQL语句。 当然也可不通过map传递，通过注解@Param实现，这样Mapper映射文件在使用参数时，就可以直接通过#{}获取即可。 案例：根据年龄和性别查询用户 mapper接口 1234//第一种方式，使用@Param注解对每个参数进行唯一标识List&lt;User&gt; selectUserByAgeAndGender(@Param(&quot;age&quot;)Integer age,@Param(&quot;gender&quot;)String gender);//第二种方式，通过Map对需要的参数进行封装List&lt;User&gt; selectUserByMap(Map&lt;String,Object&gt; map); mapper配置文件 1234567&lt;select id=&quot;selectUserByAgeAndGender&quot; resultType=&quot;com.wuxie.mybatis.entity.User&quot;&gt; select * from user where age=#&#123;age&#125; and gender=#&#123;gender&#125;&lt;/select&gt;&lt;select id=&quot;selectUserByMap&quot; parameterType=&quot;map&quot; resultType=&quot;com.wuxie.mybatis.entity.User&quot;&gt; select * from user where age=#&#123;age&#125; and gender=#&#123;gender&#125;&lt;/select&gt; 测试类 1234567891011121314151617181920212223242526272829303132public static void test4()&#123; SqlSession sqlSession = MyBatisUtil.getSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;age&quot;,22); map.put(&quot;gender&quot;,&quot;男&quot;); List&lt;User&gt; userList = userMapper.selectUserByMap(map); for(User user:userList)&#123; System.out.println(user); &#125; sqlSession.close();&#125;public static void test3()&#123; SqlSession sqlSession = MyBatisUtil.getSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.selectUserByAgeAndGender(22, &quot;女&quot;); for(User user:userList)&#123; System.out.println(user); &#125; sqlSession.close();&#125; 5.4 #{}与${}的区别正常的使用 mapper接口 1List&lt;User&gt; selectUserByKeyword(String keyword); mapper配置文件 123&lt;select id=&quot;selectUserByKeyword&quot; resultType=&quot;com.wuxie.mybatis.entity.User&quot;&gt; select * from user where name like concat(&quot;%&quot;,#&#123;value&#125;,&quot;%&quot;)&lt;/select&gt; 测试 1234567891011SqlSession sqlSession = MyBatisUtil.getSession();UserMapper userMapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; userList = userMapper.selectUserByKeyword(&quot;李&quot;);for(User user:userList)&#123; System.out.println(user);&#125;sqlSession.close(); 注意：在编写mybatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止sql注入攻击。 1234567&lt;select id=&quot;getNameByUserId&quot; resultType=&quot;String&quot;&gt; SELECT name FROM user where id = #&#123;userId&#125;&lt;/select&gt;&lt;select id=&quot;getNameByUserId&quot; resultType=&quot;String&quot;&gt; SELECT name FROM user where id = $&#123;userId&#125;&lt;/select&gt; 当userId=34;drop table user;时 第一种方式打印的SQL语句 1select name from user where id = ? 不管输入何种userID，他的sql语句都是这样的。这就得益于mybatis在底层实现时使用预编译语句。数据库在执行该语句时，直接使用预编译的语句，然后用传入的userId替换占位符？就去运行了。不存在先替换占位符？再进行编译的过程，因此SQL注入也就没有了生存的余地了。 那么mybatis是如何做到sql预编译的呢？其实框架底层使用的正是PreparedStatement类。PreparedStaement类不但能够避免SQL注入，因为已经预编译，当N次执行同一条sql语句时只需要将参数传入即可，节约了(N-1)次的编译时间，从而能够提高效率。 第二种方式打印的SQL语句 1select name from user where id = 34;drop table user; 此时就直接执行上面的SQL语句。 案例：当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。 常规写法 12345678910@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User findById(@Param(&quot;id&quot;) long id);@Select(&quot;select * from user where name = #&#123;name&#125;&quot;)User findByName(@Param(&quot;name&quot;) String name);@Select(&quot;select * from user where email = #&#123;email&#125;&quot;)User findByEmail(@Param(&quot;email&quot;) String email);// 其它的 &quot;findByXxx&quot; 方法 使用${}优化 12@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value); 此时其中 $&#123;column&#125; 会被直接替换，而 #&#123;value&#125; 会使用 ? 预处理。这样，就能完成同样的任务 123User userOfId1 = userMapper.findByColumn(&quot;id&quot;, 1L);User userOfNameKid = userMapper.findByColumn(&quot;name&quot;, &quot;kid&quot;);User userOfEmail = userMapper.findByColumn(&quot;email&quot;, &quot;noone@nowhere.com&quot;); 同样的这种方式也会引起SQL注入的 。 六、结果处理5.1 结果映射5.1.1 自动映射resultMap元素是 MyBatis 中最重要最强大的元素。它可以让你从 90%的 JDBC ResultSets数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份resultMap能够代替实现同等功能的数千行代码。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 在Mybatis的结果映射当中，通过ORM关系映射，数据库中的表对应Java中的实体类，字段对应属性；当用户查询表中的一条记录时，Mybatis的结果映射，会将记录的每个字段的值赋值给与其相同名字的属性。 同样的在Java中通常使用驼峰命名法，在数据库中通常使用下滑线来分割多个单词，通过在全局配置文件中配置，可以将对应的字段与属性一一匹配。 12345&lt;select id=&quot;selectUserById&quot; resultType=&quot;map&quot;&gt; select id , name , pwd from user where id = #&#123;id&#125;&lt;/select&gt; 上述语句只是简单地将所有的列映射到 HashMap 的键上，这由 resultType 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。 5.1.2 ResultMap①概述 resultMap 元素有很多子元素和一个值得深入探讨的结构。下面是resultMap 元素的概念视图 constructor：用于在实例化类时，注入结果到构造方法中 idArg ：ID 参数；标记出作为 ID 的结果可以帮助提高整体性能 arg：将被注入到构造方法的一个普通结果 id ：一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 result ：注入到字段或 JavaBean 属性的普通结果 association ：一个复杂类型的关联；许多结果将包装成这种类型 嵌套结果映射： 关联可以是resultMap元素，或是对其它结果映射的引用 collection： 一个复杂类型的集合 嵌套结果映射 ：集合可以是 resultMap元素，或是对其它结果映射的引用 discriminator ：使用结果值来决定使用哪个resultMap case ：基于某些值的结果映射 嵌套结果映射 ： case 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射 ②ResultMap标签 属性 描述 id 当前命名空间中的一个唯一标识，用于标识一个结果映射。 type 类的完全限定名, 或者一个类型别名（关于内置的类型别名，可以参考上面的表格）。 autoMapping 如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。默认值：未设置（unset）。 Id 和 Result 的属性 属性 描述 property 映射到列结果的字段或属性。如果 JavaBean 有这个名字的属性（property），会先使用该属性。否则 MyBatis 将会寻找给定名称的字段（field）。无论是哪一种情形，你都可以使用常见的点式分隔形式进行复杂属性导航。比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给resultSet.getString(columnName)`方法的参数一样。 javaType 一个 Java 类的全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可以为空值的列指定这个类型。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。这个属性值是一个类型处理器实现类的全限定名，或者是类型别名。 支持的 JDBC 类型 BIT FLOAT CHAR TIMESTAMP OTHER UNDEFINED TINYINT REAL VARCHAR BINARY BLOB NVARCHAR SMALLINT DOUBLE LONGVARCHAR VARBINARY CLOB NCHAR INTEGER NUMERIC DATE LONGVARBINARY BOOLEAN NCLOB BIGINT DECIMAL TIME NULL CURSOR ARRAY 5.1.3 测试简单的使用，只是处理属性名与字段名不一致的情况 当然id和result标签还有其他的属性，比如jdbType和javaType；resultMap标签也有其他的子标签。 1234567&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!-- id为主键 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt; 5.2 一对多与多对一5.2.1 多对一 多个学生对应一个老师 如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！ ①数据库环境 1234567891011121314151617181920212223CREATE TABLE `teacher` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;无邪老师&#x27;);CREATE TABLE `student` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fktid` (`tid`), CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;); ②Mapper接口 Student 123456/*** 获取所有学生及对应老师的信息* 每个学生都有一个老师，通过数据表中的tid获取老师的信息。* @return*/List&lt;Student&gt; getStudents(); ③Mapper配置文件 StudentMapper.xml 方式一 123456789101112131415161718192021&lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;com.wuxie.mybatis.entity.Student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt; &lt;!-- association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名。 select查询，将结果映射到属性teacher上--&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;com.wuxie.mybatis.entity.Teacher&quot; select=&quot;selectTeacherForStudent&quot;/&gt;&lt;/resultMap&gt; &lt;!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column=&quot;&#123;key=value,key=value&#125;&quot; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。 --&gt;&lt;select id=&quot;selectTeacherForStudent&quot; resultType=&quot;com.wuxie.mybatis.entity.Teacher&quot;&gt; select * from teacher where id=#&#123;id&#125;&lt;/select&gt; 方式二 12345678910111213&lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt; select student.id sid,student.name sname,tid,teacher.name tname from student join teacher on teacher.id=student.tid&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;com.wuxie.mybatis.entity.Student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot; /&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;com.wuxie.mybatis.entity.Teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot; /&gt; &lt;/association&gt;&lt;/resultMap&gt; ④测试 12345678910111213public static void test1()&#123; SqlSession sqlSession = MyBatisUtil.getSession(); StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); List&lt;Student&gt; students = studentMapper.getStudents(); for(Student student:students)&#123; System.out.println(student); &#125; sqlSession.close();&#125; 5.2.2 一对多查询一个老师的信息及其所有的学生信息。 ①Mapper接口 Teacher 123public interface TeacherMapper &#123; Teacher getTeacherById(Integer id);&#125; ②配置文件 方式一 1234567891011121314151617181920212223242526&lt;mapper namespace=&quot;com.wuxie.mybatis.dao.TeacherMapper&quot;&gt; &lt;!-- 思路: 1. 从学生表和老师表中查出学生id，学生姓名，老师姓名 2. 对查询出来的操作做结果集映射 1. 集合的话，使用collection！ JavaType和ofType都是用来指定对象类型的 JavaType是用来指定pojo中属性的类型 ofType指定的是映射到list集合属性中pojo的类型。 --&gt; &lt;select id=&quot;getTeacherById&quot; resultMap=&quot;TeacherStudent&quot;&gt; select s.id sid, s.name sname , t.name tname, t.id tid from student s,teacher t where s.tid = t.id and t.id=#&#123;id&#125; &lt;/select&gt; &lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;com.wuxie.mybatis.entity.Teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;com.wuxie.mybatis.entity.Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot; /&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 方式二 123456789101112131415&lt;mapper namespace=&quot;com.wuxie.mybatis.dao.TeacherMapper&quot;&gt; &lt;select id=&quot;getTeacherById&quot; resultMap=&quot;TeacherStudent2&quot;&gt; select * from teacher where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;com.wuxie.mybatis.entity.Teacher&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; column=&quot;id&quot; select=&quot;getStudentByTeacherId&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;com.wuxie.mybatis.entity.Student&quot;&gt; select * from student where tid = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; ③测试 1234567891011public static void test2()&#123; SqlSession sqlSession = MyBatisUtil.getSession(); TeacherMapper teacherMapper = sqlSession.getMapper(TeacherMapper.class); Teacher teacher = teacherMapper.getTeacherById(1); System.out.println(teacher); sqlSession.close();&#125; 5.2.3 总结1、关联-association 2、集合-collection 3、所以association是用于一对一和多对一，比如多个学生一个老师，多个员工一个部门；而collection是用于一对多的关系，一个学校多个学生等。 4、JavaType和ofType都是用来指定对象类型的 JavaType是用来指定pojo中属性的类型 ofType指定的是映射到list集合属性中pojo的类型。 5、对应一些关联查询可使用resultMap进行手动映射。 七、动态SQL7.1 概述动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 数据库环境 1234567CREATE TABLE `blog` ( `id` varchar(50) NOT NULL COMMENT &#x27;博客id&#x27;, `title` varchar(100) NOT NULL COMMENT &#x27;博客标题&#x27;, `author` varchar(30) NOT NULL COMMENT &#x27;博客作者&#x27;, `create_time` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `views` int(30) NOT NULL COMMENT &#x27;浏览量&#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8 mapper接口 1int addBlog(Blog blog); mapper配置文件 1234&lt;insert id=&quot;addBlog&quot; parameterType=&quot;com.wuxie.mybatis.entity.Blog&quot;&gt; insert into blog(id,title,author,create_time,views) values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;) &lt;/insert&gt; 测试类 12345678910111213141516171819202122232425262728SqlSession sqlSession = MyBatisUtil.getSession();BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);Blog blog1 = new Blog();blog1.setId(1);blog1.setTitle(&quot;SSM整合篇&quot;);blog1.setAuthor(&quot;无邪&quot;);blog1.setCreateTime(new Date());blog1.setViews(22);mapper.addBlog(blog1);blog1.setId(2);blog1.setTitle(&quot;Java如此简单&quot;);mapper.addBlog(blog1);blog1.setId(3);blog1.setTitle(&quot;Spring如此简单&quot;);mapper.addBlog(blog1);blog1.setId(4);blog1.setTitle(&quot;微服务如此简单&quot;);mapper.addBlog(blog1);sqlSession.commit();sqlSession.close(); 7.2 if标签①Mapper接口 1List&lt;Blog&gt; queryBlogIf(Map map); ②Mapper配置文件 1234567891011121314151617181920212223242526 &lt;!-- 根据作者名字和博客名字来查询博客！ 如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询 但如何title为空时，拼接后的sql语句就会出现语法错误，但此时可在if标签前添加一个判断条件，然后每一个if标签都先写一个and关键字 --&gt;&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;com.wuxie.mybatis.entity.Blog&quot;&gt; select * from blog where &lt;if test=&quot;title!=null&quot;&gt; title like concat(&quot;%&quot;,#&#123;title&#125;,&quot;%&quot;) &lt;/if&gt; &lt;if test=&quot;author!=null&quot;&gt; and author=#&#123;author&#125; &lt;/if&gt;&lt;/select&gt;&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; ③测试类 12345678910111213141516171819public static void test2()&#123; SqlSession sqlSession = MyBatisUtil.getSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;author&quot;,&quot;无邪&quot;); map.put(&quot;title&quot;,&quot;简单&quot;); List&lt;Blog&gt; blogs = mapper.queryBlogIf(map); for(Blog blog:blogs)&#123; System.out.println(blog); &#125; sqlSession.close(); &#125; 7.3 choose标签有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 choose标签包含两个子标签：when标签（即相当于switch的case）和otherwise标签（相当于switch的default）。 还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG。 1234567891011121314&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 7.4 trim、where标签前面提到的，当if标签的条件为false时，就会造成SQL语句的语法错误。 where元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where元素也会将它们去除。 此时的where关键字也需省略，即where标签提供了where关键字。 1234567891011&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;com.wuxie.mybatis.entity.Blog&quot;&gt; select * from blog &lt;where&gt; &lt;if test=&quot;title!=null&quot;&gt; title like concat(&quot;%&quot;,#&#123;title&#125;,&quot;%&quot;) &lt;/if&gt; &lt;if test=&quot;author!=null&quot;&gt; and author=#&#123;author&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 如果where元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制where 元素的功能。比如，和 where元素等价的自定义 trim 元素为： 123&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ...&lt;/trim&gt; prefixOverrides 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容。 7.5 set标签用于动态更新语句的类似解决方案叫做 set。 set元素可以用于动态包含需要更新的列，忽略其它不更新的列。 当参数对象中的某个属性为null时，就代表这个字段无需修改，使用set标签，也需省略关键字set 12345678910&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update 7.6 foreach标签动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候) 12345678910111213141516&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from blog where 1=1 and (id=1 or id=2 or id=3) --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 7.7 总结其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。 八、全局配置文件8.1 概述Mybatis全局配置文件的子标签 properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 注意：元素节点的顺序！在配置文件中配置的顺序不对会报错 8.2 environments标签8.2.1 概述案例 12345678910111213&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定） 因此可包含多个environment子标签，不同的运行环境，使用的数据连接池属性也各不相同，不如开发时和上线后使用的数据库肯定是不一样的。 8.2.2 environment标签 dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 数据源是必须配置的。 有三种内建的数据源类型 1type&#x3D;&quot;[UNPOOLED|POOLED|JNDI]&quot;） unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。 pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等…. 详情：点击查看官方文档 这两种事务管理器类型都不需要设置任何属性。 具体的一套环境，通过设置id进行区别，id保证唯一！ 子元素节点：transactionManager - [ 事务管理器 ] 12&lt;!-- 语法 --&gt;&lt;transactionManager type&#x3D;&quot;[ JDBC | MANAGED ]&quot;&#x2F;&gt; 子元素节点：数据源（dataSource） 8.3 mappers标签 映射器 : 定义映射SQL语句文件 既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。 总而言之，该标签的作用就是讲Mapper接口相应的Mapper配置文件一一对应。 引入资源方式 1234&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt; 1234&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt; 1234567&lt;!--将包内的映射器接口实现全部注册为映射器但是需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; 8.4 Properties优化数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。 ①建立相应的properties文件 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8username=rootpassword=123456 ②引入properties文件 12345678910111213141516171819202122232425&lt;configuration&gt; &lt;!--导入properties文件--&gt; &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;!-- 也可这样使用 --&gt; &lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt; &lt;/properties&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 8.5 typeAliases优化类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。 1234&lt;!--配置别名,注意顺序--&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.wuxie.entity.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt; 当这样配置时，User可以用在任何使用com.wuxie.entity.User的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean 123&lt;typeAliases&gt; &lt;package name=&quot;com.wuxie.entity&quot;/&gt;&lt;/typeAliases&gt; 每一个在包 com.wuxie.entity 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 8.6 setting常用的设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;settings&gt; &lt;!-- 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否允许单个语句返回多结果集（需要数据库驱动支持） --&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。 --&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;!-- 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。 --&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;!-- 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 --&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;!-- 指定发现自动映射目标未知列（或未知属性类型）的行为。 NONE: 不做任何反应 WARNING: 输出警告日志（&#x27;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#x27; 的日志等级必须设置为 WARN） FAILING: 映射失败 (抛出 SqlSessionException) --&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;!-- 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。 --&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;!-- 设置超时时间，它决定数据库驱动等待数据库响应的秒数。 --&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;!-- 为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。 --&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;!-- 是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 。 --&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;!-- 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;!-- MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。 --&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;!-- 当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 --&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;!-- 指定对象的哪些方法触发一次延迟加载。 --&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt; 8.7 其他配置类型处理器 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】 对象工厂 MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】 九、缓存9.1 概述1、什么是缓存 [ Cache ]？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 2、为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 3、什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。 9.2 Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 一级缓存也叫本地缓存： 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库。 9.3 测试①加入日志 1234&lt;settings&gt; &lt;!-- 加入日志，输出到控制台 --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; ②测试 123456789User user = userMapper.queryUserById(1);System.out.println(user);System.out.println(&quot;第二次查询&quot;);User user2 = userMapper.queryUserById(1);System.out.println(user2); ③效果 以上情况使用的是一级缓存，默认开启。 9.4 一级缓存失效的情况一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它； 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求。 ①SqlSession不同时，一级缓存会失效，同样的请求会从数据库在查询一次 12345678910111213141516@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); session2.close();&#125; 结论：每个sqlSession中的缓存相互独立 ②SqlSession相同，查询条件不同 1234567891011121314@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(2); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 观察结果：发现发送了两条SQL语句！很正常的理解 结论：当前缓存中，不存在这个数据 ③SqlSession相同，两次查询之间执行了增删改操作！ 1234567891011121314151617181920@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); HashMap map = new HashMap(); map.put(&quot;name&quot;,&quot;kuangshen&quot;); map.put(&quot;id&quot;,4); mapper.updateUser(map); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 结论：因为增删改操作可能会对当前数据产生影响 ④SqlSession相同，手动清除一级缓存 1234567891011121314151617@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.clearCache();//手动清除缓存 User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 9.5 二级缓存9.5.1 概述 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 9.5.2 使用步骤①全局配置文件中开启缓存 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; ②去每个mapper.xml中配置使用二级缓存，这个配置非常简单 1234567&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 ③测试，所有的实体类先实现序列化接口 123456789101112131415161718@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.close(); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session2.close();&#125; 结论 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中 9.6 缓存原理图 9.7 EhCache第三方缓存实现–EhCache: 查看百度百科 Ehcache是一种广泛使用的java分布式缓存，用于通用缓存； 要在应用程序中使用Ehcache，需要引入依赖的jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt; 在mapper.xml中使用对应的缓存即可 123&lt;mapper namespace = “org.acme.FooMapper” &gt; &lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&gt; &lt;/mapper&gt; 编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --&gt; &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt; &lt;defaultCache eternal=&quot;false&quot; maxElementsInMemory=&quot;10000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;259200&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;cache name=&quot;cloud_user&quot; eternal=&quot;false&quot; maxElementsInMemory=&quot;5000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;1800&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统当机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 --&gt;&lt;/ehcache&gt; 十、分页10.1 PageHelperMyBatis分页插件，分页插件支持任何复杂的单表、多表分页。 官网地址：https://pagehelper.github.io/ 10.2 PageHelper的简单使用①PageHelper依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt; &lt;artifactId&gt;pagehelper&lt;&#x2F;artifactId&gt; &lt;version&gt;最新版本&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; ②全局配置文件配置插件 12345678910111213141516171819&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name=&quot;param1&quot; value=&quot;value1&quot;/&gt; &lt;!-- PageHelper提供的参数很多，具体详见官网，这里简单介绍几个常用的； reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询； helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言；配置时，可以使用下面的缩写值oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012，否则会使用 SqlServer2005 的方式进行分页 --&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; ③使用 PageHelper的使用方式有很多，不同的使用场景有不同的使用方式，这里只介绍一种。 mapper接口 1List&lt;Phone&gt; selectAllPhones(); mapper映射文件 123&lt;select id=&quot;selectAllPhones&quot; resultType=&quot;com.wuxie.mybatis.entity.Phone&quot;&gt; select * from phone&lt;/select&gt; service层 1234567891011121314151617181920public class PhoneService &#123; private PhoneMapper phoneMapper; public PhoneService(PhoneMapper phoneMapper)&#123; this.phoneMapper=phoneMapper; &#125; public PageInfo getPhoneByPage(int pageNum,int pageSize)&#123; //开启分页，第一个参数页数，第二个参数页大小 PageHelper.startPage(pageNum,pageSize); //查询所有记录，此时分页插件会进行分页 List&lt;Phone&gt; phones = phoneMapper.selectAllPhones(); //封装分页信息，这个类封装了大量的关于分页的信息，包括分页查询结果，当前页码，总页数，总记录数等信息 PageInfo&lt;Phone&gt; pageInfo = new PageInfo&lt;Phone&gt;(phones); return pageInfo; &#125;&#125; 测试 123456789101112Reader reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);SqlSession session=sqlSessionFactory.openSession();//相当于开启事务PhoneMapper mapper = session.getMapper(PhoneMapper.class);PhoneService phoneService = new PhoneService(mapper);PageInfo pageInfo = phoneService.getPhoneByPage(1, 3);System.out.println(pageInfo); 十一、使用注解开发11.1 环境搭建实体类 123456789public class Blog &#123; private Integer id; private String title; private String author; private Date createTime; private Integer views; //get、set等方法&#125; BlogMapper 123public interface BlogMapper &#123;&#125; 在mybatis-config注册 1234&lt;mappers&gt; &lt;mapper resource=&quot;mapper/PhoneMapper.xml&quot;&gt;&lt;/mapper&gt; &lt;mapper class=&quot;com.wuxie.mybatis.mapper.BlogMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 11.2 @Insert接口 1234@Insert(&quot;insert into &quot; + &quot;blog(id,title,author,create_time,views) &quot; + &quot;values(#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;) &quot;)int addBlog(Blog blog); 测试 12345678910111213141516Reader reader = null;try &#123; reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);SqlSession session=sqlSessionFactory.openSession();//相当于开启事务BlogMapper blogMapper = session.getMapper(BlogMapper.class);blogMapper.addBlog(new Blog(5,&quot;测试&quot;,&quot;AmazingDL&quot;,new Date(),256));session.commit();//提交事务，对数据库进行增删改时一定要提交事务session.close(); 11.3 @Update12345678910@Update(&quot;&lt;script&gt;&quot; + &quot;update blog&quot; + &quot;&lt;set&gt;&quot; + &quot;&lt;if test=\\&quot;title != null\\&quot;&gt;title=#&#123;title&#125;,&lt;/if&gt;&quot; + &quot;&lt;if test=\\&quot;author != null\\&quot;&gt;author=#&#123;author&#125;,&lt;/if&gt;&quot; + &quot;&lt;if test=\\&quot;views != null\\&quot;&gt;views=#&#123;views&#125;,&lt;/if&gt;&quot; + &quot;&lt;/set&gt;&quot; + &quot;where id = #&#123;id&#125;&quot;+ &quot;&lt;/script&gt;&quot;)int updateBlog(Blog blog); 说明：这里是用来动态SQL，其他的动态SQL标签与此类似。 11.4 @Delete12@Delete(&quot;delete from blog where id = #&#123;id&#125;&quot;)int deleteBlogById(Integer id); 11.5 @Select12@Select(&quot;select * from blog&quot;)Blog selectBlogs(Integer id); 11.6 @Results环境搭建与上面类似，这里就不赘述了。 一对多结果查询 TeacherMapper 123456789101112131415161718192021public interface TeacherMapper &#123; /** * 说明： * 1.@Result的id定义之后，可在通过@ResultMap使用该结果映射 * 2.这里演示的一对多查询，查询结果可以懒加载 */ @Select(&quot;select * from teacher where id =#&#123;id&#125;&quot;) @Results(id = &quot;teacherResult&quot;,value = &#123; @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;name&quot;,property = &quot;name&quot;), @Result(column = &quot;id&quot;,property = &quot;students&quot;, many = @Many(select = &quot;com.wuxie.mybatis.mapper.StudentMapper.queryStudentsByTeacherId&quot;, fetchType = FetchType.LAZY))//调用其他接口的查询方法 &#125;) Teacher queryTeacherById(Integer id); @Select(&quot;select * from teacher&quot;) @ResultMap(&quot;teacherResult&quot;)//使用上面定义的结果映射 List&lt;Teacher&gt; queryAllTeachers();&#125; StudentMapper 12@Select(&quot;select * from student where tid = #&#123;teacherId&#125;&quot;)List&lt;Student&gt; queryStudentsByTeacherId(Integer teacherId); 测试 1234567891011121314151617181920Reader reader = null;try &#123; reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);SqlSession session=sqlSessionFactory.openSession();//相当于开启事务TeacherMapper teacherMapper = session.getMapper(TeacherMapper.class);List&lt;Teacher&gt; list = teacherMapper.queryAllTeachers();for(Teacher teacher : list)&#123; System.out.println(teacher);&#125;session.commit();session.close(); 一对一查询 StudentMapper 123456789101112@Select(&quot;select * from student where id = #&#123;studentId&#125;&quot;)@Results(&#123; @Result(id = true,column = &quot;id&quot;,property = &quot;id&quot;), @Result(column = &quot;name&quot;,property = &quot;name&quot;), @Result(column = &quot;tid&quot;,property = &quot;teacher&quot;, one = @One( select = &quot;com.wuxie.mybatis.mapper.TeacherMapper.queryTeacherById&quot;, fetchType = FetchType.LAZY ) )&#125;)Student queryStudentById(Integer studentId); 测试 123456789101112131415161718Reader reader = null;try &#123; reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);SqlSession session=sqlSessionFactory.openSession();//相当于开启事务StudentMapper studentMapper = session.getMapper(StudentMapper.class);Student student = studentMapper.queryStudentById(1);System.out.println(student);session.commit();session.close(); 十二、结束语以上内容就是MyBatis的简单介绍，主要还是对数据的操作。 参考文档：https://mybatis.org/mybatis-3/zh/index.html","categories":[{"name":"Java","slug":"Java","permalink":"https://amazingdl.github.io/categories/Java/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://amazingdl.github.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"数据结构(三)——二叉树","slug":"数据结构/二叉树","date":"2020-11-06T23:20:47.000Z","updated":"2020-11-12T08:11:45.403Z","comments":true,"path":"2020/11/07/数据结构/二叉树/","link":"","permalink":"https://amazingdl.github.io/2020/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"树形结构是一类重要的非线性结构。其中以树和二叉树最为常用，直观来看，树是以分支关系定义的层次结构。树结构在客观世界中广泛存在，比如各种社会组织结构和人类社会的族谱等都可以用树来形象表示。本篇博客主要是关于二叉树的简单使用。","text":"一、树形结构 什么是树？树是n(n&gt;=0)个结点的有限集！ 在任意一个非空树中，有以下特点： 有且仅有一个特定的称为根的结点； 当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集，其中每一个集合本身又是一颗数，并且称为根的子树。 树的结构示意图如下： 相关概念 结点：树的结点包含一个数据元素及若干个指向其子树的分支，结点拥有的子树数称为结点的度，如上图中的A结点的度为9，B结点的度为3； 其中度为0的结点称为叶子结点，度不为0的称为分支结点； 树的度是树内各结点的度的最大值，如上图树的度为9。 在树中，结点之间的关系类似于人类族谱之间的关系。 如B、C、D结点称为A结点的孩子；B结点称为E、F、G结点的双亲。 E、F、G结点之间互称兄弟。 一个结点的祖先节点是从根结点到该结点所经分支上的所有结点。 反之，以某结点为根的子树中的任一结点都称为该结点的子孙。 森林 森林是m(m&gt;=0)棵互不相交的树的集合，对于树的每个结点而言，其子树的集合即为森林。 二、二叉树的简单介绍二叉树是另一种树形结构，它的特点是每个结点至多只有两棵子树，并且，二叉树的子树有左右之分，其次序不能任意颠倒。 二叉树的链式存储结构： 1234567891011121314151617181920class BinaryTreeNode&#123; Object data; BinaryTreeNode left; BinaryTreeNode right; public BinaryTreeNode() &#123; &#125; public BinaryTreeNode(Object data) &#123; super(); this.data = data; &#125; public BinaryTreeNode(Object data, BinaryTreeNode left, BinaryTreeNode right) &#123; super(); this.data = data; this.right = right; this.left = left; &#125;&#125; 二叉树的遍历： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 简单的二叉树工具类，包括二叉树的遍历和重建 * @author AmazingDL * */public class BinaryTreeUtil &#123; /** * 前序遍历二叉树，根左右 */ public static void preOrderTraverse(BinaryTreeNode node) &#123; if(node == null) &#123; return ; &#125; System.out.print(node.data+&quot; &quot;); preOrderTraverse(node.left); preOrderTraverse(node.right); &#125; /** * 中序遍历二叉树，左根右 */ public static void middleOrderTraverse(BinaryTreeNode node) &#123; if(node == null) &#123; return ; &#125; middleOrderTraverse(node.left); System.out.print(node.data+&quot; &quot;); middleOrderTraverse(node.right); &#125; /** * 后序遍历二叉树，左右根 */ public static void nextOrderTraverse(BinaryTreeNode node) &#123; if(node == null) &#123; return ; &#125; nextOrderTraverse(node.left); nextOrderTraverse(node.right); System.out.print(node.data+&quot; &quot;); &#125; &#125; 测试： 12345678910111213141516171819202122232425262728public class BinaryTreeTest &#123; public static void main(String[] args) &#123; BinaryTreeNode root = buildSimpleBinaryTree(); System.out.println(&quot;先序遍历序列&quot;); BinaryTreeUtil.preOrderTraverse(root); System.out.println(); System.out.println(&quot;中序遍历序列&quot;); BinaryTreeUtil.middleOrderTraverse(root); System.out.println(); System.out.println(&quot;后序遍历序列&quot;); BinaryTreeUtil.nextOrderTraverse(root); &#125; public static BinaryTreeNode buildSimpleBinaryTree() &#123; BinaryTreeNode root = new BinaryTreeNode(); root.data=&quot;A&quot;; root.left = new BinaryTreeNode(&quot;B&quot;,new BinaryTreeNode(&quot;D&quot;,new BinaryTreeNode(&quot;G&quot;),new BinaryTreeNode(&quot;H&quot;)),new BinaryTreeNode(&quot;F&quot;)); root.right = new BinaryTreeNode(&quot;C&quot;,null,new BinaryTreeNode(&quot;I&quot;,new BinaryTreeNode(&quot;J&quot;),new BinaryTreeNode(&quot;K&quot;))); return root; &#125;&#125; 重建二叉树： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//重构二叉树public static BinaryTreeNode rebuildBinaryTree(int[] preArray,int[] middleArray) &#123; if(preArray==null||middleArray==null) &#123; return null; &#125; //获取rootValue在middleArray的下标 int rootIndexInMiddleArray = 0; //左子树节点的数量 int leftCount = 0; //右子树节点的数量 int rightCount = 0; //获取根节点在中序遍历序列的位置 for(int i = 0;i&lt;middleArray.length;i++) &#123; if(preArray[0]==middleArray[i]) &#123; rootIndexInMiddleArray = i; break; &#125; leftCount++; &#125; rightCount = middleArray.length-leftCount-1; //获取左子树的前序遍历序列和中序遍历序列 int[] leftInPreArray = null; int[] leftInMiddleArray = null; if(rootIndexInMiddleArray!=0) &#123; leftInPreArray = Arrays.copyOfRange(preArray, 1 ,leftCount+1);//范围复制数组，前闭后开 leftInMiddleArray = Arrays.copyOfRange(middleArray,0, rootIndexInMiddleArray); &#125; //获取右子树的前序遍历序列和中序遍历序列 int[] rightInPreArray = null; int[] rightInMiddleArray = null; if(rootIndexInMiddleArray!=middleArray.length-1) &#123; rightInPreArray = Arrays.copyOfRange(preArray, leftCount+1, preArray.length); rightInMiddleArray = Arrays.copyOfRange(middleArray, rootIndexInMiddleArray+1, middleArray.length); &#125; //构建根节点，根本思想就是将一个树分为若干个子树去重构，当一个结点构成一颗树时，就返回 BinaryTreeNode root = new BinaryTreeNode(); root.value = preArray[0]; if(leftInMiddleArray==null &amp;&amp; rightInMiddleArray == null) &#123; root.leftChild = null; root.rightChild = null; &#125; else if(leftInMiddleArray==null) &#123; root.leftChild = null; root.rightChild = rebuildBinaryTree(rightInPreArray,rightInMiddleArray); &#125; else if(rightInMiddleArray == null) &#123; root.rightChild = null; root.leftChild = rebuildBinaryTree(leftInPreArray,leftInMiddleArray); &#125; else &#123; root.leftChild = rebuildBinaryTree(leftInPreArray,leftInMiddleArray); root.rightChild = rebuildBinaryTree(rightInPreArray,rightInMiddleArray); &#125; return root;&#125; 三、赫夫曼树及其应用","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://amazingdl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://amazingdl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"消息队列之RabbitMQ的简单使用","slug":"技术杂谈/RabbitMQ","date":"2020-11-01T06:27:46.000Z","updated":"2020-11-12T12:21:06.985Z","comments":true,"path":"2020/11/01/技术杂谈/RabbitMQ/","link":"","permalink":"https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/","excerpt":"MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法。在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量","text":"一、消息队列概述MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法。 RabbitMQ是一个Erlang开发的AMQP（Advanced Message Queuing Protocol ）的开源实现。 1.1 为什么使用MQ在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。 开发中消息队列通常有如下应用场景： **(1) 异步提速: ** ​ 任务异步处理将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。 **(2) 应用解耦: ** ​ 应用程序解耦合，MQ充当中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合 **(3) 削峰填谷: ** ​ 在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用MQ能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。 **(4) 可恢复性: ** ​ 系统的一部分组件失效时，不会影响到整个系统。MQ降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。 (5) 排序保证： ​ 消息队列可以控制数据处理的顺序，因为消息队列本身使用的是队列这个数据结构，FIFO(先进选出)，在一些场景数据处理的顺序很重要，比如商品下单顺序等。 1.2. 消息队列产品市场上常见的消息队列有如下： ActiveMQ：基于JMS实现, 比较均衡, 不是最快的, 也不是最稳定的. ZeroMQ：基于C语言开发, 目前最好的队列系统. RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好, 数据基本上不会丢失 RocketMQ：基于JMS，阿里巴巴产品, 目前已经捐献给apahce, 还在孵化器中孵化. Kafka：类似MQ的产品；分布式消息系统，高吞吐量, 目前最快的消息服务器, 不保证数据完整性. 1.3. AMQP 和 JMS Dubbo协议：Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。 AMQP协议：即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。 MQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。 1.3.1. AMQPAMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。 1.3.2. JMSJMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 1.3.3. AMQP 与 JMS 区别JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。JMS规定了两种消息模式；而AMQP的消息模式更加丰富. JMS AMQP 定义 Java api Wire-protocol 跨语言 否 是 跨平台 否 是 1.4. RabbitMQRabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。 RabbitMQ官方地址：http://www.rabbitmq.com/ RabbitMQ提供了6种模式：Hello Word简单模式，work工作模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式(通配符模式)，RPC远程调用模式（远程调用，不太算MQ；不作介绍） 官网对应模式介绍：https://www.rabbitmq.com/getstarted.html 应用场景： 1、双十一商品秒杀/抢票功能实现 我们在双11的时候，当我们凌晨大量的秒杀和抢购商品，然后去结算的时候，就会发现，界面会提醒我们，让我们稍等，以及一些友好的图片文字提醒。而不是像前几年的时代，动不动就页面卡死，报错等来呈现给用户。 2、积分兑换(积分可用于多平台) 积分兑换模块，有一个公司多个部门都要用到这个模块，这时候就可以通过消息队列解耦这个特性来实现。 各部门系统做各部门的事，但是他们都可以用这个积分系统进行商品的兑换等。其他模块与积分模块完全解耦。 3、大平台用户注册 发送邮件、用户大数据分析操作等 基于同步变异步功能实现 用户注册真实操作步骤： 用户注册选择的兴趣标签，根据用户的属性，行为进行用户分析，计算出推荐内容 注册后可能需要发送邮件给用户 发送短信给用户 发送给用户指南的系统通知 …等等 正常情况注册，不出现高并发，假如有大量的用户注册，发生了高并发，就会出现如下情况： 邮件接口承受不住，或是分析信息时的大量计算使 cpu 满载，这将会出现虽然用户数据记录很快的添加到数据库中了，但是却卡在发邮件或分析信息时的情况，导致请求的响应时间大幅增长，甚至出现超时，这就有点不划算了。面对这种情况一般也是将这些操作放入消息队列（生产者消费者模型），消息队列慢慢的进行处理，同时可以很快的完成注册请求，不会影响用户使用其他功能。 1.5 相关定义：1.Message 消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 2.Publisher 消息的生产者，也是一个向交换器发布消息的客户端应用程序。 3.Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。4.Binding 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。5.Queue 消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。 6.Connection 网络连接，比如一个TCP连接。 7.Channel 信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。 8.Consumer 消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 9.Virtual Host 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。 10.Broker 表示消息队列服务器实体。 ==由Exchange、Queue、RoutingKey三个才能决定一个消息从Exchange到Queue的唯一的线路。== 二、Spring Boot整合RabbitMQ在spring boot项目中，只需要引入start-amqp起步依赖，即可整合RabbitMQ成功；我们基于SpringBoot封装的RabbitTemplate模板对象，可以非常方便的发送消息，接收消息(使用注解)。 amqp的官方GitHub地址：https://github.com/spring-projects/spring-amqp 一般在开发过程中，我们有两个角色： 相关依赖 1234567&lt;dependencies&gt; &lt;!--amqp协议的起步依赖坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 相关配置 12345678910# rabbitmq主机地址和端口号spring.rabbitmq.host=localhostspring.rabbitmq.port=5672# 用户和密码spring.rabbitmq.username=wuxiespring.rabbitmq.password=123456# 配置虚拟主机，作用把消息队列进行权限划分，不同部门拥有同一个消息队列的不同虚拟主机spring.rabbitmq.virtual-host=/amazingdl 常见队列、交换机并绑定 12345678910111213141516171819202122232425262728293031323334353637/** * 通过Java代码创建交换机、消息队列，并绑定交换机与消息队列 */@Configurationpublic class RabbitConfiguration &#123; //创建消息队列 @Bean public Queue orderQueue()&#123; /** * 第一个参数：消息队列名 * 第二个参数：是否持久化 * 第三个参数：是否独占 * 第四个参数：是否自动删除 */ return new Queue(&quot;order.test&quot;,true,false,false); &#125; //创建交换机，路由交换机，这里还有其他类型的交换机，不同的工作模式有不同交换机 @Bean public DirectExchange orderExchange()&#123; /** * 第一个参数：交换机名成 * 第二个参数：是否持久化 * 第三个参数：是否自动删除 */ return new DirectExchange(&quot;order_test_exchange&quot;,true,false); &#125; //交换机与消息队列的绑定 @Bean public Binding exchangeBindingQueue(Queue orderQueue,DirectExchange orderExchange)&#123; //BindingBuilder.bind(队列对象).to(交换机对象).with(路由键) return BindingBuilder.bind(orderQueue).to(orderExchange).with(&quot;&quot;); &#125;&#125; 三、消息队列的五种工作模式3.1 简单模式 什么是简单模式 在上图的模型中，有以下概念： **P：生产者: ** 也就是要发送消息的程序 C：消费者：消息的接受者，会一直等待消息到来。 queue：消息队列，图中红色部分。可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。 创建simple_queue消息队列，可通过图形化界面操作，也可通过Java代码 生产者发送消息 123456789101112@AutowiredRabbitTemplate rabbitTemplate;@Testpublic void sendMsg()&#123; /** * 参数一：消息队列的名称 * 参数二：消息队列的内容 */ rabbitTemplate.convertAndSend(&quot;simple_queue&quot;,&quot;你好，这是消息队列提供者!&quot;);&#125; 消费者接收消息 1234567891011121314/** * 简单模式下的监听者，监听队列中是否有消息，如果有消息，触发接收方法，打印消息 * 注入Spring容器 */@Component@RabbitListener(queues = &quot;simple_queue&quot;)//当前监听器的监听队列public class SimpleConsumerListener &#123; @RabbitHandler public void simpleConsumerHandler(String msg)&#123;//参数为消息的内容 System.out.println(&quot;监听的内容：&quot;+msg); &#125;&#125; 3.2 工作队列模式Work Queues与入门程序的简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。 在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是竞争的关系。 创建work_queue队列 生产者发送消息 1234567891011121314151617/** * 工作模式消息队列，一个生产者，多个消费者竞争消费 */@SpringBootTestpublic class WorkQueueTest &#123; @Autowired RabbitTemplate rabbitTemplate; @Test public void sendMsg()&#123; for (int i = 0; i &lt; 1000; i++) &#123; rabbitTemplate.convertAndSend(&quot;work_queue&quot;,&quot;这是第&quot;+i+&quot;条消息&quot;); &#125; &#125;&#125; 消费者接收消 第一个消费者 12345678910@Component@RabbitListener(queues = &quot;work_queue&quot;)public class WorkConsumerListener &#123; //监听消息的回调方法，处理监听消息 @RabbitHandler public void msgHandler(String msg)&#123; System.out.println(&quot;msgHandler【1】接收到的消息：&quot;+msg); &#125;&#125; 第二个消费者 12345678910@Component@RabbitListener(queues = &quot;work_queue&quot;)public class WorkConsumerListener2 &#123; @RabbitHandler public void msgHandler2(String msg)&#123; System.out.println(&quot;msgHandler【2】接收到的消息：&quot;+msg); &#125;&#125; 3.3 发布、订阅模式发布订阅模式： ​ 1、每个消费者监听自己的队列。 ​ 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息 【广播消息：一次性将消息发送给所有消费者，每个消费者收到消息均一致】 创建两个队列 创建交换机 绑定交换机 生产者发送消息 1234567891011121314151617181920/** * 发布订阅模式 * 一个生产者，多个消费者，每个消费者接收的内容相同，发布订阅模式 */@SpringBootTestpublic class FanoutQueueTest &#123; @Autowired RabbitTemplate rabbitTemplate; /** * 参数一：设置交换机 * 参数二：设置路由键，广播模式默认不设置路由键，为空字符串 * 参数三：设置消息 */ @Test public void sendMsg()&#123; rabbitTemplate.convertAndSend(&quot;fanout_exchange&quot;,&quot;&quot;,&quot;你好，这是广播模式发布者&quot;); &#125;&#125; 消费者接收消息 12345678910111213/** * 发布订阅模式 */@Component@RabbitListener(queues = &quot;fanout_queue1&quot;)public class FanoutConsumerListener1 &#123; //监听消息的回调方法，处理监听消息 @RabbitHandler public void msgHandler(String msg)&#123; System.out.println(&quot;msgHandler【1】接收到的消息：&quot;+msg); &#125;&#125; 12345678910@Component@RabbitListener(queues = &quot;fanout_queue2&quot;)public class FanoutConsumerListener2 &#123; //监听消息的回调方法，处理监听消息 @RabbitHandler public void msgHandler(String msg)&#123; System.out.println(&quot;msgHandler【2】接收到的消息：&quot;+msg); &#125;&#125; 3.4 路由模式路由模式特点： 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）消息的发送方在向 Exchange发送消息时，也必须指定消息的RoutingKey。Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的Routing key完全一致，才会接收到消息。 图解： P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。 X：Exchange（交换机），接收生产者的消息，然后把消息递交给与routing key完全匹配的队列 C1：消费者，其所在队列指定了需要routing key 为 error 的消息 C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息 【有选择性的接收消息】 创建routing_queue1和routing_queue2队列 创建交换机routing_exchange 绑定消息队列 生产者发送消息 12345678910111213141516171819202122/** * 路由模式 * 一个生产者，多个消费者，每个消费者通过路由键指定接收消息的队列 */@SpringBootTestpublic class RoutingQueueTest &#123; @Autowired RabbitTemplate rabbitTemplate; /** * 参数一：设置交换机 * 参数二：设置路由键，广播模式默认不设置路由键，为空字符串 * 参数三：设置消息 */ @Test public void sendMsg()&#123; rabbitTemplate.convertAndSend(&quot;routing_exchange&quot;,&quot;info&quot;,&quot;你好，这是路由模式发布者，info信息&quot;); rabbitTemplate.convertAndSend(&quot;routing_exchange&quot;,&quot;error&quot;,&quot;你好，这是路由模式发布者，error信息&quot;); &#125;&#125; 消费者接收消息 12345678910111213/** * 发布订阅模式 */@Component@RabbitListener(queues = &quot;routing_queue1&quot;)public class RoutingConsumerListener1 &#123; //监听消息的回调方法，处理监听消息 @RabbitHandler public void msgHandler(String msg)&#123; System.out.println(&quot;msgHandler【1】接收到的消息：&quot;+msg); &#125;&#125; 12345678910@Component@RabbitListener(queues = &quot;routing_queue2&quot;)public class RoutingConsumerListener2 &#123; //监听消息的回调方法，处理监听消息 @RabbitHandler public void msgHandler(String msg)&#123; System.out.println(&quot;msgHandler【2】接收到的消息：&quot;+msg); &#125;&#125; 根据路由键，交换机将消息发送到不同的队列，然后每个队列对应的消费者去消费。 3.5 通配符模式Topic类型与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key的时候使用通配符！ Routingkey: 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如：item.insert 通配符规则： #：匹配一个或多个词，多个词用点号分隔 *：匹配不多不少恰好1个词 举例： item.#： 能够匹配item.insert.abc.bbc或者item.insert *item.：只能匹配item.insert 创建队列topic_queue1和topic_queue2 创建交换机 绑定消息队列 生产者发送消息 12345678910111213141516171819202122/** * 通配符模式 * 一个生产者，多个消费者，每个消费者通过路由键指定接收消息的队列，路由键是有通配符规定 */@SpringBootTestpublic class TopicQueueTest &#123; @Autowired RabbitTemplate rabbitTemplate; /** * 参数一：设置交换机 * 参数二：设置路由键，广播模式默认不设置路由键，为空字符串 * 参数三：设置消息 */ @Test public void sendMsg()&#123; rabbitTemplate.convertAndSend(&quot;topic_exchange&quot;,&quot;item.insert.abc&quot;,&quot;你好，这是路由模式发布者，item.*接收信息&quot;); rabbitTemplate.convertAndSend(&quot;topic_exchange&quot;,&quot;item.insert&quot;,&quot;你好，这是路由模式发布者，item.#接收信息&quot;); &#125;&#125; 消费者接收消息 12345678910111213/** * 发布订阅模式 */@Component@RabbitListener(queues = &quot;topic_queue1&quot;)public class TopicConsumerListener1 &#123; //监听消息的回调方法，处理监听消息 @RabbitHandler public void msgHandler(String msg)&#123; System.out.println(&quot;msgHandler【1】接收到的消息：&quot;+msg); &#125;&#125; 12345678910@Component@RabbitListener(queues = &quot;topic_queue2&quot;)public class TopicConsumerListener2 &#123; //监听消息的回调方法，处理监听消息 @RabbitHandler public void msgHandler(String msg)&#123; System.out.println(&quot;msgHandler【2】接收到的消息：&quot;+msg); &#125;&#125; 根据路由通配符的匹配规则，不同的消息会进入不同的队列，然后由绑定该队列的消费者接收。 3.6 总结工作模式： **1、简单模式 HelloWorld : ** 一个生产者、一个消费者，不需要设置交换机（使用默认的交换机） 2、工作队列模式 Work Queue: 一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机） 3、发布订阅模式 Publish/subscribe: **需要设置类型为==fanout==**的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息广播发送到绑定的队列 4、路由模式 Routing: ** 需要设置类型为==direct==**的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列 5、通配符模式 Topic: ** 需要设置类型为==**topic==的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列 四、消息队列的高级特性4.1 生产者确认在生产者向消息队列发送消息时，由于各种原因，可能会导致生产者向消息队列发送消息失败。 比如： 第一，生产者发送消息给MQ失败，消息丢失； 第二，交换机路由到队列失败，路由键写错； 在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式。 confirm 确认模式 return 退回模式 rabbitmq 整个消息投递的路径为： 消息从生产者(producer)发送消息到交换机(exchange)，不论是否成功，都会执行一个确认回调方法confirmCallback 。 消息从交换机(exchange)到消息队列( queue )投递失败则会执行一个返回回调方法 returnCallback 。 我们将利用这两个 callback 控制消息的可靠性投递 确认模式 依赖 12345678910&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 1234567891011# 当然这里也包含了一些其他相关的配置# 开启生产者确认模式：(confirm),投递到交换机，不论失败或者成功都回调spring.rabbitmq.publisher-confirms=true# 在2.2.0及之后该属性过期使用spring.rabbitmq.publisher-confirm-type属性配置代替# 选择确认类型为交互# NONE值是禁用发布确认模式，是默认值# CORRELATED值是发布消息成功到交换器后会触发回调方法，如1示例# SIMPLE值经测试有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果返回false则会关闭channel，则接下来无法发送消息到broker;spring.rabbitmq.publisher-confirm-type=correlated 确认回调类 123456789101112131415161718192021222324252627282930313233/** * 生产者发送消息回调类 */@Componentpublic class MessageConfirmCallback implements RabbitTemplate.ConfirmCallback&#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 当前类的对象创建完之后，执行的方法，post代表后，pre代表前 * 然后将当前对象设置给rabbitTemplate */ @PostConstruct public void init()&#123; //设置确认回调方法 rabbitTemplate.setConfirmCallback(this::confirm); &#125; /** * 确认回调方法，为了确定消息进入了交换机 * @param correlationData 封装消息相关的数据 * @param ack 消息是否发送成功，true代表发送成功 * @param cause 失败的原因 */ @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; if(ack)&#123; System.out.println(&quot;消息成功进入了交互机&quot;); &#125; else&#123; System.out.println(&quot;消息失败，消息原因：&quot;+cause); &#125; &#125;&#125; 发送消息 12345678910111213141516171819@RestControllerpublic class MessageController &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 向消息队列发送消息 * @param exchange * @param routingKey * @param msg * @return */ @RequestMapping(value = &quot;/direct/sendMsg&quot;) public String sendMsg(String exchange,String routingKey,String msg)&#123; rabbitTemplate.convertAndSend(exchange,routingKey,msg); return &quot;消息已投递&quot;; &#125;&#125; 此时的消费者接收消息与前面相同 回退模式 配置文件 12# 开启消息回退模式spring.rabbitmq.publisher-returns=true 回调类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 生产者发送消息回调类 */@Componentpublic class MessageConfirmCallback implements RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnCallback &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 当前类的对象创建完之后，执行的方法，post代表后，pre代表前 * 然后将当前对象设置给rabbitTemplate */ @PostConstruct public void init()&#123; //设置确认回调方法 rabbitTemplate.setConfirmCallback(this::confirm); //设置回退回调方法 rabbitTemplate.setReturnCallback(this::returnedMessage); &#125; /** * 确认回调方法，为了确定消息进入了交换机 * @param correlationData 封装消息相关的数据 * @param ack 消息是否发送成功，true代表发送成功 * @param cause 失败的原因 */ @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; if(ack)&#123; System.out.println(&quot;消息成功进入了交互机&quot;); &#125; else&#123; System.out.println(&quot;消息失败，消息原因：&quot;+cause); &#125; &#125; /** * 回调回调方法，为了确定消息进入了队列 * @param message 发送的内容 * @param replyCode 错误状态码 * @param replyText 错误原因 * @param exchange 交换机名称 * @param routingKey 路由名称 */ @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) &#123; System.out.println(&quot;发送消息失败，交互机路由队列错误&quot;); System.out.println(&quot;发送消息：&quot;+message); System.out.println(&quot;错误状态码：&quot;+replyCode); System.out.println(&quot;错误信息：&quot;+replyText); System.out.println(&quot;交互机：&quot;+exchange); System.out.println(&quot;路由键：&quot;+routingKey); &#125;&#125; 此时发送消息与接收消息与确认模式相同。 说明： 确认模式： 设置publisher-confirms=”true”或 spring.rabbitmq.publisher-confirm-type=correlated 开启 确认模式。 实现RabbitTemplate.ConfirmCallback接口，重写confirm方法 特点：不论消息是否成功投递至交换机，都回调confirm方法，只有在发送失败时需要写业务代码进行处理。 退回模式 设置publisher-returns=”true” 开启 退回模式。 实现RabbitTemplate.ReturnCallback接口，重写returnedMessage方法 特点：消息进入交换机后，只有当从exchange路由到queue失败，才去回调returnedMessage方法； 4.2 消费者确认为了达到消费者能百分百接收到请求，且业务执行过程中还不能出错！需要消费者手动确认。 ack指 Acknowledge，拥有确认的含义，是消费端收到消息的一种确认机制； 消息确认的三种类型： 自动确认：acknowledge=”none“ 手动确认：acknowledge=”manual“ 根据异常情况确认：acknowledge=”auto“，（这种方式使用麻烦，不作讲解） 其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。 如果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息。 自定义监听器涉及三个对象：三个对象必须注入Spring容器 自定义监听器对象 自定义监听器的适配器Adaptor对象 监听器的容器对象 创建自定义监听器类CustomAckConsumerListener，实现ChannelAwareMessageListener接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 自定义监听器，用于接收消息队列order.A发送的消息 */@Componentpublic class CustomAckConsumerListener implements ChannelAwareMessageListener &#123; /** * 自定义监听器的监听方法，作用：监听消息队列发送过来的消息，然后执行当前方法 * 监听器三要素： * 监听对象：消息队列 * 事件源：消息 * 执行操作：执行的操作onMessage * @param message 消息的内容 * @param channel 频道，就是在生产者、消费者与消息队列的连接中包含多个channel，详见消息队列结构图 * @throws Exception */ @Override public void onMessage(Message message, Channel channel) throws Exception &#123; //1、获取消息队列中的消息 String messageBody = new String(message.getBody(), &quot;utf-8&quot;); //获取投递标签 MessageProperties messageProperties = message.getMessageProperties(); long deliveryTag = messageProperties.getDeliveryTag(); try&#123; //2、执行业务逻辑 System.out.println(&quot;执行正常的逻辑，消息的内容：&quot;+messageBody); //模拟异常情况// if(messageBody.contains(&quot;苹果&quot;))&#123;// throw new RuntimeException(&quot;苹果手机不能卖&quot;);// &#125; //可通过休眠，延时消费端限流的情况 //3、正常，签收消息 //第一个参数：投递标签 //第二个参数：是否是批量签收，如果是true，将当前队列对应链接中的所有消息一次签收，false只签收当前消息 channel.basicAck(deliveryTag,false); System.out.println(&quot;手动签收&quot;); &#125; catch (Exception e)&#123; //4、异常拒签消息，消息重回消息队列 //第三个参数：是否从回队列 System.out.println(&quot;手动拒签，原因：&quot;+e.getMessage()); channel.basicNack(deliveryTag,false,true); &#125; &#125;&#125; 编写监听器配置类ListenerConfiguration，配置自定义监听器绑定消息队列order.A并配置适配器实体类 1234567891011121314151617181920212223242526272829303132333435363738394041@Configurationpublic class ListenerConfiguration &#123; //自定义监听器的适配器对象，在配置类中@Bean的方法可直接自动注入Spring容器的对象 @Bean public MessageListenerAdapter messageListenerAdapter(CustomAckConsumerListener listener)&#123; return new MessageListenerAdapter(listener); &#125; /** * 监听器容器对象 * 设置链接工厂对象，链接放的是channel, ConnectionFactory 连接工厂 * 设置自定义监听对象的适配器对象 MessageListenerAdapter * 设置绑定的消息对象 order.A * 设置手动签收模式 ackKnowledgeMode 手动签收 MANUAL */ @Bean public SimpleMessageListenerContainer simpleMessageListenerContainer( MessageListenerAdapter messageListenerAdapter, ConnectionFactory connectionFactory)&#123; SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(); //设置自定义监听对象的适配器对象 container.setMessageListener(messageListenerAdapter); //设置链接工厂对象 container.setConnectionFactory(connectionFactory); //绑定当前消息队列 container.setQueueNames(&quot;order.A&quot;); //设置手动签收模式,MANUAL-手动签收；NONE-自动签收；AUTO-出现异常签收 container.setAcknowledgeMode(AcknowledgeMode.MANUAL); //设置消费端限流，限制每次只拉去一条消息，默认每次拉去250条 container.setPrefetchCount(1); return container; &#125;&#125; 说明： 如果想手动签收消息，那么需要自定义实现消息接收监听器，实现ChannelAwareMessageListener接口 设置AcknowledgeMode模式 none：自动 auto：异常模式 manual：手动 调用channel.basicAck方法签收消息 调用channel.basicNAck方法拒签消息 4.3 消费端限流 如上图所示： 第一种情况： 如果在A系统中需要维护相关的业务功能，可能需要将A系统的服务停止，那么这个时候消息的生产者还是一直会向MQ中发送待处理的消息，消费者此时服务已经关闭，导致大量的消息都会在MQ中累积。 如果当A系统成功启动后，消费者会一次性将MQ中累积的大量的消息拉取到自己的服务，导致服务在短时间内会处理大量的业务，可能会导致系统服务的崩溃。 所以消费端限流是非常有必要的。 第二种情况：当大量用户注册时，高并发请求过来，邮件接口只支持小量并发，这时消费端限流也非常必要； 消费端限流配置：设置监听器容器属性container.setPrefetchCount(1)；表示消费端每次从mq拉去1条消息来消费，直到手动确认消费完毕后，才会继续拉去下一条消息。 实现步骤： 在自定义消息监听器配置类ListenerConfiguration类中，配置每次拉取消息1条container.setPrefetchCount(1); 1234567891011121314151617181920212223242526/** * 注入消息监听器容器 * @param connectionFactory 连接工厂 * @param messageListenerAdapter 自定义的消息监听器适配器 */@Beanpublic SimpleMessageListenerContainer simpleMessageListenerContainer( ConnectionFactory connectionFactory, MessageListenerAdapter messageListenerAdapter)&#123; //简单的消息监听器容器对象 SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(); //绑定消息队列 container.setQueueNames(&quot;order.A&quot;); //设置连接工厂对象 container.setConnectionFactory(connectionFactory); //设置消息监听器适配器 container.setMessageListener(messageListenerAdapter); //设置手动确认消息：NONE(不确认消息)，MANUAL(手动确认消息)，AUTO(自动确认消息) container.setAcknowledgeMode(AcknowledgeMode.MANUAL); //设置消费端限流，每次拉取消息多少条，默认是250条 container.setPrefetchCount(1); return container;&#125; 说明 消费端自定义消息监听器绑定消息队列时，设置每次拉取消息1条setPrefetchCount(1); 注意，如果想进行消费端限流，那么消息必须手动确认，AcknowledgeMode为MANUAL 4.4 TTLTTL 全称 Time To Live（存活时间/过期时间）。当消息到达存活时间后，还没有被消费，会被自动清除。 RabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间。 注意：给单个消息设置过期时间没实际意义。 在RabbitMQ管理控制台中，新增消息队列order，并设置消息失效时间为5秒 也可在发送消息时，设置过期时间 说明： 设置队列过期时间使用参数：x-message-ttl，单位：ms(毫秒)，会对整个队列消息统一过期。 由于队列是先进先出的，所以如果设置单个消息的过期时间并没有实际意义 例如：设置消息A的过期时间为10秒，消息B的过期时间为5秒，但是先将消息A发送至队列，那么只有等消息A被消费或者到期移除后才会将消息B消费或者到期移除。 4.5 死信队列死信队列：当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是Dead Letter Exchange（死信交换机 简写：DLX）。 消息成为死信的三种情况： 队列消息长度到达限制； 消费者拒接消息(basicNack)，并且不把消息重新放回源队列，requeue=false； 源队列存在消息过期设置，消息到达超时时间未被消费； 设置死信队列绑定死信交换机： 给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key 案例目标：演示消息队列中消息超时失效 实现步骤： 在RabbitMQ管理控制台中，创建死信队列deadQueue 在RabbitMQ管理控制台中，创建死信交换机deadExchange 死信队列绑定死信交换机，路由键为order.dead 消息队列order.B绑定死信交换机 向消息队列order.B中发送消息【消息队列order.B中的消息失效时间为5秒】 在RabbitMQ管理控制台中，将消息队列order.B绑定到交换机order_exchange上 等待5秒，消息队列order.B中的消息进入死信队列 创建deadqueue 创建deadExchange 死信队列绑定死信交换机，路由键为dead 创建队列order.B，并绑定死信交换机 队列order.B绑定交换机并发送消息 结果 说明： 死信交换机和死信队列和普通的没有区别 当消息成为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列 消息成为死信的三种情况： 队列消息长度到达限制； 消费者拒接消费消息，并且不重回队列； 原队列存在消息过期设置，消息到达超时时间未被消费； 4.6 延迟队列什么是延迟队列？即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费。 需求场景： 下单后，30分钟未支付，取消订单，回滚车票。 新用户注册成功7天后，发送短信问好。 实现方法： 定时器 延迟队列 注意：在RabbitMQ中并未提供延迟队列功能。 但是可以使用：TTL+死信队列 组合实现延迟队列的效果。 五、结束语通过上面的学习，能够在项目中简单的使用消息队列。","categories":[{"name":"中间件","slug":"中间件","permalink":"https://amazingdl.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"消息队列","slug":"消息队列","permalink":"https://amazingdl.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}]},{"title":"数据结构(二)——栈和队列","slug":"数据结构/栈和队列","date":"2020-10-28T00:50:50.000Z","updated":"2020-11-06T23:56:50.645Z","comments":true,"path":"2020/10/28/数据结构/栈和队列/","link":"","permalink":"https://amazingdl.github.io/2020/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"栈和队列是两种重要的线性结构。从数据结构角度来看，湛河队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集；但从数据类型角度来看，它们是和线性表大不相同的两类重要的抽象数据类型。","text":"一、栈 什么是栈？ 栈是限定仅在表尾进行插入或删除操作的线性表。因此，对于栈来说，表尾端被称为栈顶，表头端被称为栈底，不含元素的空表称为空栈。 在栈中，出栈的第一个元素是栈顶元素，即栈的修改是按后进先出的原则进行的，因此栈又称为后进先出的线性表。 其结构示意图如下： 顺序栈的表示和实现 和线性表类似，栈也有两种存储表示方法：顺序栈和链栈。 顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。 其结构实现如下： 123456class Stack&#123; private Object[] data;//存储栈内容的数组 private int top;//栈顶指针 private int base;//栈底指针 private int size;//栈的元素个数&#125; 说明： data用于存放栈的元素，当data数组长度不够时，需要扩容； base是指向栈底的下标，top是指向栈顶的下标，非空栈的栈顶指针始终在栈顶元素的下一个位置上； 元素每次入栈时，top需要自增1，base不需改变； 元素每次出栈时，top需要自减1，当top与base相等时，栈为空； 栈的入栈示意图： 实现代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * 顺序栈 * @author AmazingDL * */public class SequenceStack &#123; private Object[] elementData; private int base; private int top; private int size; private static final int DEFAULT_LENGTH = 10; /** * 创建默认长度的栈 */ public SequenceStack() &#123; this(DEFAULT_LENGTH); &#125; /** * 创建指定长度的栈 */ public SequenceStack(int length) &#123; elementData = new Object[length]; base = 0; top = 0; size = 0; &#125; /** * 入栈，如果栈满就提醒栈满，无法扩容 * @param data */ public void push(Object data) &#123; if(top!=elementData.length) &#123; elementData[top] = data; top++; size++; &#125; else &#123; System.out.println(&quot;栈满，无法添加&quot;+data+&quot;元素了&quot;); &#125; &#125; /** * 出栈 * @return */ public Object pop() &#123; if(top==base) &#123; System.out.println(&quot;栈空，没有元素出栈&quot;); return null; &#125; Object result = elementData[--top]; return result; &#125; /** * 元素个数 * @return */ public int size() &#123; return this.size; &#125; /** * 是否为空 * @return */ public boolean isEmpty() &#123; return this.base==this.top; &#125; public void display() &#123; for(int i = 0;i&lt;this.size;i++) &#123; System.out.print(elementData[i]+&quot; &quot;); &#125; System.out.println(); &#125;&#125; 链栈的表示 链栈，与顺序栈的操作类似，指示栈的每个元素使用一个结点表示，结点之间的操作与单链表的操作类似； 栈顶指针指向栈顶结点，不设置栈底指针，当栈顶指针为null时，栈为空，第一个元素入栈时，创建一个结点，且栈顶指针指向该结点； 链栈的删除元素示意图： 链栈的代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LinkedStack &#123; private StackNode top; public LinkedStack() &#123; &#125; public void push(Object data) &#123; StackNode node = new StackNode(); node.data = data; //当栈为空栈时，第一个入栈的元素即为栈顶元素 if(top == null) &#123; node.prev = null; top = node; &#125; else &#123; node.prev = top; top = node; &#125; &#125; public Object pop() &#123; if(top==null) &#123; System.out.println(&quot;栈空&quot;); return null; &#125; StackNode result = top; top = top.prev; return result.data; &#125; public boolean isEmpty() &#123; return this.top==null; &#125; //略 class StackNode&#123; Object data; //每个结点的指针域指向前一个结点，栈底结点的指针域为null StackNode prev; &#125;&#125; 二、栈的相关案例通过栈实现十进制数N和其他进制数之间的转换 12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; System.out.print(&quot;请输入一个十进制整数：&quot;); Scanner scan = new Scanner(System.in); int number = scan.nextInt(); System.out.print(&quot;请输入要转换的进制：&quot;); int n = scan.nextInt(); System.out.println(&quot;将十进制数&quot;+number+&quot;转换为&quot;+n+&quot;进制数&quot;); LinkedStack stack = new LinkedStack(); while(number&gt;0) &#123; //每次取余 stack.push(new Integer(number%n)); //将商继续进行转换 number = number/n; &#125; //遍历栈 StringBuilder sb = new StringBuilder(); while(!stack.isEmpty()) &#123; sb.append(stack.pop()); &#125; System.out.println(sb.toString());&#125; 三、队列 什么是队列？ 和栈相反，队列是一种先进先出的线性表，它只允许在表的一端进行元素插入操作，而在另一端进行元素的删除操作。 与现实生活中的排队一致，最早进入队列的元素最早离开，即先进先出。 在队列中，允许插入的一端叫做队尾，允许删除的一端则成为队头。 队列结构示意图： 链队列的表示和实现 用链表表示的队列称为链队列，一个链队列显然需要两个分别指向队头和队尾的指针才能唯一确定。 在设计队列时，也可给链队列添加一个头结点，并令头指针指向头结点，由此，空的链队列的判断条件就是头指针和尾指针均指向头结点。 链队列结构示意图： 链队列的代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 链队列 * @author AmazingDL * */public class LinkedQueue &#123; private QueueNode front;//队首 private QueueNode rear;//队尾 private int size;//元素个数 public LinkedQueue() &#123; this.front = new QueueNode();//头结点，不存储任何元素 this.rear = this.front;//空队列，队首指针和队尾指针均指向头结点 this.size = 0; &#125; //入队 public void EnQueue(Object data) &#123; QueueNode node = new QueueNode(); node.data = data; this.rear.next = node; this.rear = node; this.size++; &#125; //出队 public Object DeQueue() &#123; Object result = this.front.next.data; this.front = this.front.next; this.size--; return result; &#125; public int size() &#123; return this.size; &#125; public boolean isEmpty() &#123; return this.rear == this.front; &#125; class QueueNode &#123; Object data; QueueNode next; &#125;&#125; 循环队列——队列的顺序表示和实现 与顺序栈类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列为的元素之外，还需设置front和rear分别指向队列头元素及队列尾元素的位置。 在顺序队列的表示中，为了方便起见，初始化建空队列时，令front=rear=0。 每当插入新的队尾元素时，尾指针自增1；每当删除队列头元素时，头指针自增1。 因此，在非空队列中，头指针始终只想队列头元素，而尾指针始终指向队列尾元素的下一个位置。 队列表示示意图： 在顺序队列中，当队尾指针等于数组长度时，继续插入元素就会出现数组越界异常，然而此时又不宜如顺序栈那样，进行存储在分配扩大数组空间，因为队列的实际可用空间并未占满。 循环队列：将顺序队列臆造为一个环状空间，如下图所示： 由于队列的特殊结构，队列的长度一般都是可以确定的，在循环队列下亦是如此。 所以判断一个队列空间是空还是满就很重要了，当队列满了的时候，就告诉外界无法添加元素。 在元素入列或元素出列时，front和rear都是在不断增加的，但队列的长度时固定的，所以可通过(front+1)%size和(rear+1)%size的方式获取入列元素和出列元素在数组中的下标。 然而在循环队列中，只通过front==rear是无法判断一个队列空间是空还是满。 此时有两种处理方法： 其一是另设一个标识位以区分队列是空还是满； 其二是少用一个空间元素，约定以“队列头指针在队列尾指针的下一位置上作为队列呈满状态的标志。 循环队列的代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 循环队列 * @author AmazingDL * */public class SequenceQueue &#123; private Object[] elementData; private int front; private int rear; private int size; private static final int DEFAULT_LENGTH = 10; public SequenceQueue() &#123; this(DEFAULT_LENGTH); &#125; public SequenceQueue(int length) &#123; elementData = new Object[length]; this.front = 0; this.rear = 0; this.size = 0; &#125; public void EnQueue(Object data) &#123; //判断队列是否已满 if((this.rear+1) % this.elementData.length == this.front) &#123; System.out.println(&quot;队列已满&quot;); return; &#125; elementData[this.rear] = data; this.size++; //当rear等于elementData.length-1时，需要对其加一后的数值进行处理，即通过取余，使得0&lt;=rear&lt;=elementData.length this.rear = (this.rear+1) % this.elementData.length; &#125; public Object DeQueue() &#123; //判断队列是否为空 if(this.front == this.rear) &#123; System.out.println(&quot;队列为空&quot;); return null; &#125; Object result = this.elementData[this.front]; //当front等于elementData.length-1时，需要对其加一后的数值进行处理，即通过取余，使得0&lt;=front&lt;=elementData.length this.front = (this.front+1) % this.elementData.length; return result; &#125; public int size() &#123; return this.size; &#125;&#125; 四、结束语 在线性结构中，栈和队列的操作还是比较简单的，元素的增加和删除只能从某一端进行； 通过栈和队列的顺序存储结构和链式存储结构的实现，可以简单的认识一下这种特殊的线性结构。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://amazingdl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://amazingdl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构(一)——线性表","slug":"数据结构/线性表","date":"2020-10-28T00:43:19.000Z","updated":"2020-11-06T23:56:45.807Z","comments":true,"path":"2020/10/28/数据结构/线性表/","link":"","permalink":"https://amazingdl.github.io/2020/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"在数据元素的非空有限集合中，如果除了第一个数据元素和最后一个数据元素之外，每个数据元素只存在一个直接前驱元素和一个直接后继元素，那么这种数据结构就是线性结构；线性结构有很多，比如线性表、栈、队列等；现实生活中线性结构的案例也很多，比如食堂排队，所以学会线性结构的特点和操作是及其重要的。所以，这次就从线性表开始说起。","text":"一、数据结构和算法 谈数据结构之前，先认识一下几个相关的概念： 数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 对于计算机而言，数据的含义极为广泛，如图像、声音等都可以通过编码而归于数据的范畴。 数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。有时，一个数据元素可由若干个数据项组成。 例如一个人的详细信息为一个数据元素，那么这个人的身高、年龄、性别都是一个数据项。 数据对象：是性质相同的数据元素的集合，是一个数据的子集。 例如，字母字符数据对象是集合C={‘A’,’B’,……,’Z’}。 那么什么是数据结构呢？ 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 在任何问题中，数据元素都不是孤立存在的； 比如当我们取银行办理业务时，需要排队，此时每个需要办理业务的人对于某个窗口来说都是一个数据元素，这些人之间也存在着某种特定的关系，例如每个人只能从队列的末尾进，从队首出，且除了第一个人，其他每个人的前面都有且只有一个需要办理业务的人，这就是线性结构的一种特点，当然这种线性结构还存在着其他关系，这些数据元素相互之间的关系成为结构。 数据结构的四种分类： 集合：结构中的数据元素之间除了“同属于一个集合”的关系之外，别无其他关系； 线性结构：结构中的数据元素之间存在一个对一个的关系； 树形结构：结构中的数据元素之间存在一个对多个的关系； 图形结构或网状结构：结构中的数据元素之间存在多个对多个的关系。 数据结构的相关概念 逻辑结构：结构定义中的“关系”描述的是数据元素之间的逻辑关系； 物理结构：数据结构在计算机上的实成为物理结构； 元素或节点：在计算机中，我们可以用一个由若干位组合起来形成的一维串表示一个数据元素，这个位串成为元素或节点。当数据元素由若干数据项组成时，位串中对应于各个数据项的子位串称为数据域。 顺序存储结构：顺序存储结构的特点是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，比如数组。 链式存储结构：链式存储结构的特点就是借助指向元素存储地址的引用(或指针)表示数据元素之间的逻辑关系。 数据类型 在高级程序语言的编写中，每个变量都有一个它所属的确定的数据类型，类型明显或隐含地规定了在程序执行期间变量所有可能取值的范围，以及在这些值上允许进行的操作。 因此数据类型是一个值的集合和定义在这个值上的一组操作的总称。比如整型变量，其值就是整数的集合，定义在其上的操作为加、减、乘、除等操作。 原子数据类型：原子类型的值是不可分解的，比如Java中的基本数据类型int、char、double等。 结构数据类型：结构类型的值是由若干成分按某种结构组成，因此是可以分解的，且它的成分可以是非结构的，也可以是结构的。比如数组，数组的元素可以int类型的，也可以是数组类型的(构成二维数组)。 抽象数据类型 抽象数据类型是指一个数据模型以及定义在该模型上的一组操作，抽象数据类型的定义取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关，即不论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用。 抽象数据类型格式 12345ADT 抽象数据类型名&#123; 数据对象:&lt;数据对象的定义&gt; 数据关系:&lt;数据关系的定义&gt; 基本操作:&lt;基本操作的定义&gt;&#125;ADT 抽象数据类型名 算法 算法是对特定问题求解步骤的一种描述，它是指令的有限集合，其中一条指令表示一个或多个操作； 算法的五个特性： 有穷性：一个算法必须总是在执行有穷步后结束，且每一步都可在有穷时间内完成； 确定性：算法中每一条指令必须有确切的含义，读者理解时不会产生二义性。并且，在任何条件下，算法只有唯一的一条执行路径，即对于相同的输入只能得出相同的输出； 可行性：一个算法是能行的，计算法中描述的操作都是可以通过实现的基本运算执行有限次来实现的； 输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合； 输出：一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量。 通常通过一个算法的时间复杂度和空间复杂度来描述一个算法的效率。 二、线性表的类型定义 线性结构的特点 在数据元素的非空有限集合中 存在唯一的一个被称做“第一个”的数据元素； 存在唯一的一个被称做“最后一个”的数据元素； 除第一个之外，集合中的每个数据元素均只有一个前驱； 除最后一个之外，集合中的每个数据元素均只有一个后继。 如果把食堂排队打饭的每个人看做一个数据元素，那么排队的这些人构成的集合属于线性结构。 什么是线性表 线性表属于线性结构中的一种最常用且最简单的数据结构。 线性表中的每个数据元素的具体含义，在不同的情况下各不相同，他可以是一个数或一个符号，也可以是一页书，甚至更复杂的信息。 线性表中的数据元素可以是各种各样的，但同一线性表中的数据元素必定具有相同特性。 另外，对于具有“一对一”逻辑关系的数据，我们一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语： 某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”； 某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”； 常用算法 ①将存在于A表而不存在于B表的数据元素插入到表A中。 12345678910111213141516171819202122232425262728public static void test1() &#123; int[] arr1 = new int[] &#123;2,5,6,7,8&#125;; int[] arr2 = new int[] &#123;3,6,8,9,10,18,25&#125;; int[] result = Arrays.copyOf(arr2, arr1.length+arr2.length);//复制并扩容数组2。 int count = 0; //记录插入的元素个数 for(int i = 0 ;i&lt;arr1.length;i++) &#123; boolean flag = false; for(int j = 0;j&lt;arr2.length;j++) &#123; if(arr1[i]==arr2[j]) &#123; flag = true;//存在相同元素 &#125; &#125; if(!flag) &#123; result[arr2.length+count]=arr1[i]; count++; &#125; &#125; for(int i = 0;i&lt;(arr2.length+count);i++) &#123; System.out.print(result[i]+&quot;\\t&quot;); &#125;&#125; ②已知线性表A和B中的数据元素按值非递减有序排列，现要求A和B合并为一个新的线性表C，且C的数据元素仍按值非递减有序排列。 123456789101112131415161718192021222324252627282930313233/** * 合并两个有序数组到另外一个数组中 * @param a * @param b */public static void mergeList(int[] a,int[] b) &#123; int[] c = new int[a.length+b.length]; int x = 0;//记录数组a的下标 int y = 0;//记录数组b的下标 int k = 0;//记录数组c的下标 while(x&lt;a.length &amp;&amp; y &lt; b.length) &#123; if(a[x]&lt;=b[y]) &#123; c[k++] = a[x++]; &#125; else &#123; c[k++] = b[y++]; &#125; &#125; //此时还需要判断两个数组是否已经全部遍历完 while(x&lt;a.length) &#123; c[k++] = a[x++]; &#125; while(y&lt;b.length) &#123; c[k++] = b[y++]; &#125; System.out.println(Arrays.toString(c));&#125; 三、顺序表线性表的顺序表示指的是一组地址连续的存储单元依次存储线性表的数据元素。 以下是我参照java.util.ArrayList类，写出的一个简单的List，只包含一些简单的增删改查方法； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170/** * 实现自己的ArrayList，未使用泛型，使用Object存储元素 * @author AmazingDL * */public class ArrayList &#123; //容器 private Object[] elementData; //默认数组长度 private static final int DEFAULT_LENGTH= 10; //元素个数 private int size = 0; public ArrayList() &#123; elementData = new Object[this.DEFAULT_LENGTH]; &#125; public ArrayList(int length) &#123; if(length&lt;0) &#123; elementData = new Object[this.DEFAULT_LENGTH]; &#125; else if(length&gt;Integer.MAX_VALUE) &#123; throw new RuntimeException(&quot;数组长度异常&quot;); &#125; else &#123; elementData = new Object[length]; &#125; &#125; /** * 数组扩容 * @param minCapacity 扩容后的最小长度 */ private void grow(int minCapacity) &#123; if(minCapacity&gt;Integer.MAX_VALUE) &#123; throw new RuntimeException(&quot;数组长度异常&quot;); &#125; int oldCapacity = elementData.length; //扩容1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //判断扩容1.5倍后的大小是否仍能够满足需求 if(newCapacity-minCapacity&lt;0) &#123; newCapacity = minCapacity; &#125; elementData = Arrays.copyOf(elementData, newCapacity); &#125; /** * 指定索引下插入元素 * @param index 插入的位置 * @param target 需要插入的元素 */ public void add(int index,Object target) &#123; //插入的元素的下标只能小于elementData.length且大于0，即列表的元素是连续的 if(index&lt;0||index&gt;=elementData.length) &#123; throw new RuntimeException(&quot;下标越界&quot;); &#125; //当元素个数等于数组长度时，数组扩容 if((this.size+1)&gt;=elementData.length) &#123; this.grow(this.size+1); &#125; //当插入的索引等于size时，需移动元素，然后在index位置插入元素 if(index!=this.size) &#123; for(int i = this.size;i&gt;=index;i--) &#123; elementData[i] = elementData[i-1]; &#125; &#125; //当插入的索引等于size时，无需移动元素 elementData[index]=target; this.updateSize();//更新元素个数 &#125; /** * 删除指定索引下的元素 * @param index * @return */ public Object delete(int index) &#123; if(this.get(index)!=null) &#123; for(int i = index;i&lt;this.size;i++) &#123; elementData[i] = elementData[i+1];//先赋值，后自增 &#125; this.updateSize();//更新元素个数 return this.get(index); &#125; return null; &#125; //修改元素 public void update(int index,Object target) &#123; if(this.get(index)!=null) &#123; elementData[index] = target; &#125; else &#123; throw new RuntimeException(&quot;下标错误&quot;); &#125; &#125; /** * 根据索引查找元素 * @param index * @return */ public Object get(int index) &#123; if(index &lt;0 || index &gt;=this.size) &#123; return null; &#125; return elementData[index]; &#125; //元素个数 public int size() &#123; return this.size; &#125; //更新元素个数 private void updateSize() &#123; int count = 0; for(int i = 0;i&lt;this.elementData.length;i++) &#123; if(elementData[i]!=null) &#123; count++; &#125; &#125; this.size = count; &#125; /** * 没有元素即为空，返回true * @return */ public boolean isEmpty() &#123; return this.size()==0; &#125; //遍历数组 public String toString() &#123; StringBuilder result = new StringBuilder(); for(int i = 0;i&lt;this.size;i++) &#123; result.append(elementData[i].toString()); &#125; return result.toString(); &#125; &#125; 四、单链表与顺序存储结构不同的是，它不要求逻辑上相邻的元素在物理位置也相邻。因此对于链式存储结构的操作，增加和删除就不需要移动元素，但是每次查询和修改都需要遍历整个链式存储结构 线性链表 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。 为了表示每个数据元素与其直接后继元素之间的逻辑关系，每个数据元素除了存储本身的信息之外，还需存储一个指示其直接后继的信息，即直接后继的存储位置；这两部分信息组成数据元素的存储结构，称为结点。 结点中存储数据元素信息的域称为数据域，存储直接后继存储位置的域称为指针域。 链表的每个结点中只包含一个指针域，称为单链表。 单链表的结构如下图： 头结点：单链表的第一个结点之前附设一个结点，称之为头结点； 头结点的数据域可以不存储任何信息，也可存储如线性表的长度等附加信息； 头结点的指针域存储的是头指针，指示链表的第一个结点的存储位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240/** * 单链表 * @author AmazingDL * */public class LinkedList &#123; private Node first; private Node last; public LinkedList() &#123; this.first = new Node(); this.last = first; &#125; /** * 列表末尾增加元素 * @param data 元素的数据 */ public void add(int data) &#123; //创建结点 Node element = new Node(); element.data = data; Node node = this.first; //获取最后一个结点，此时只要结点的next为null，该结点即为最后一个结点。 while(node.next!=null) &#123; node = node.next; &#125; node.next = element; this.last = element; &#125; /** * 指定位置插入元素 * @param index 索引；在列表中，索引从0开始，索引为0的表示头结点， * @param data 元素 */ public void insert(int index,int data) &#123; if(index == 0 ) &#123; throw new RuntimeException(&quot;无法在头结点添加元素&quot;); &#125; if(index &gt; this.size()+1) &#123; throw new RuntimeException(&quot;下标越界&quot;); &#125; //创建结点 Node element = new Node(); element.data = data; //索引比列表元素个数大1时，即在链表的末尾添加元素，直接调用add方法 if(index == this.size()+1) &#123; this.add(data); return ; &#125; //获取插入位置元素的前驱元素 Node node = this.getIndexPriorElement(index); System.out.println(&quot;插入位置的前驱元素内容&quot;+node.data); //将element的next指向插入位置的元素 element.next = node.next; //将前驱元素的next指向element node.next = element; &#125; //删除元素 public int delete(int index) &#123; if(index == 0 ) &#123; throw new RuntimeException(&quot;无法删除头结点&quot;); &#125; if(index &gt; this.size()) &#123; throw new RuntimeException(&quot;下标越界&quot;); &#125; //获取删除位置元素的前驱元素 Node node = this.getIndexPriorElement(index); int result = node.next.data; if(index == this.size()) &#123; node.next = null; this.last = node; &#125; else &#123; node.next = node.next.next; &#125; return result; &#125; //修改元素 public void update(int index,int value) &#123; if(index == 0 ) &#123; throw new RuntimeException(&quot;无法更新头结点元素&quot;); &#125; if(index &gt; this.size()) &#123; throw new RuntimeException(&quot;下标越界&quot;); &#125; //获取修改位置元素 Node node = this.getIndexPriorElement(index).next; node.data = value; &#125; //查询元素 public int get(int index) &#123; if(index == 0 ) &#123; throw new RuntimeException(&quot;无法获取头结点数据&quot;); &#125; if(index &gt; this.size()) &#123; throw new RuntimeException(&quot;下标越界&quot;); &#125; //获取修改位置元素 Node node = this.getIndexPriorElement(index).next; return node.data; &#125; //元素个数 public int size() &#123; //头结点不包含元素 Node node = this.first.next; int size = 0; //下一个结点为空时，循环结束 while(node!=null) &#123; size++; node = node.next; &#125; return size; &#125; //是否为空 public boolean isEmpty() &#123; return this.first.next==null; &#125; //遍历链表 public void display() &#123; //从第二个结点开始遍历，头结点不包含元素 Node node = this.first.next; while(node!=null) &#123; System.out.print(node.data+&quot; &quot;); node = node.next; &#125; System.out.println(); &#125; /** * 找到指定索引位置的前驱元素 * @return */ private Node getIndexPriorElement(int index) &#123; if(index == 0) &#123; throw new RuntimeException(&quot;头结点没有前驱元素&quot;); &#125; int count = 1; Node node = this.first; //找到插入位置元素及其前驱元素 while(node.next.next!=null) &#123; if(count == index) &#123; break; &#125; count++; node = node.next; &#125; return node; &#125; //获取头结点 public Node head() &#123; return this.first; &#125; public Node firstElement() &#123; return this.first.next; &#125; public int getFirstElementValue() &#123; return this.first.next.data; &#125; public Node last() &#123; return this.last; &#125; public int getLastElementValue() &#123; return this.last.data; &#125; /** * 节点类 * @author AmazingDL * */ public class Node&#123; int data; Node next; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; &#125;&#125; 说明： 索引问题，上述案例中头结点的索引为0，第一个存储的元素的索引为1； 元素个数问题，对于元素个数可直接在类中添加size属性，只需在链表元素个数变化更新时即可，不用每次调用size方法就遍历整个链表，且size方法返回的是链表元素的个数，不是链表的结点数量； 节点数据域，数据域存储的信息可以是任何类型的，比如double、char、boolean等类型，也可是一个自定义类，甚至是一个链表；所以在设置节点的数据域时，可使用Object类型，也可以使用泛型提高代码重用性。 first属性表示第一个结点，即头结点；last属性表示最后一个结点。 五、双向链表双向链表的结点 12345class DNode&#123; Object data;//数据信息 DNode prev;//直接前驱元素 DNode next;//直接后继元素&#125; 双向链表：双向链表的结点包含两个指针域，其一指向直接后继，其一指向直接前驱，通过这种方式，可使指针在链表上的移动更加方便，但也使用了更多的内存空间。 结构如下图 代码实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183/** * 双向链表 * @author AmazingDL * */public class DuplexLinkedList &#123; private DNode head; /** * 初始化链表，创建头结点 */ public DuplexLinkedList() &#123; head = new DNode(); &#125; //增加元素 public void add(String data) &#123; //构建结点 DNode element = new DNode(); element.data = data; DNode node = head; while(node.next!=null) &#123; node = node.next; &#125; node.next = element; element.prior = node; &#125; //插入元素 public void insert(int index,String vlaue) &#123; if(index &lt;= 0 || index &gt; this.size()) &#123; throw new RuntimeException(&quot;索引不合法&quot;); &#125; //构建结点 DNode element = new DNode(); element.data = vlaue; DNode node = this.getNodeByIndex(index); //获取直接前驱元素 DNode priorNode = node.prior; element.next = node; node.prior = element; priorNode.next = element; element.prior = priorNode; &#125; //删除元素 public String delete(int index) &#123; if(index &lt;= 0 || index &gt; this.size()) &#123; throw new RuntimeException(&quot;索引不合法&quot;); &#125; DNode node = this.getNodeByIndex(index); //获取直接前驱元素 DNode priorNode = node.prior; //获取直接后继元素 DNode nextNode = node.next; //删除元素 priorNode.next = nextNode; nextNode.prior = priorNode; return node.data; &#125; //修改元素 public void update(int index,String value) &#123; if(index &lt;= 0 || index &gt; this.size()) &#123; throw new RuntimeException(&quot;索引不合法&quot;); &#125; DNode node = this.getNodeByIndex(index); node.data = value; &#125; //查询元素 public String get(int index) &#123; if(index &lt;= 0 || index &gt; this.size()) &#123; throw new RuntimeException(&quot;索引不合法&quot;); &#125; return this.getNodeByIndex(index).data; &#125; //元素个数，头结点不算一个元素 public int size() &#123; DNode node = head.next; int size = 0; while(node!=null) &#123; size++; node = node.next; &#125; return size; &#125; //是否为空 public boolean isEmpty() &#123; return head.next==null; &#125; //遍历列表 public void display() &#123; DNode node = head.next; while(node!=null) &#123; System.out.print(node.data+&quot; &quot;); node = node.next; &#125; System.out.println();//换行 &#125; //根据索引获取指定位置结点 public DNode getNodeByIndex(int index) &#123; if(index == 0) &#123; return head; &#125; if(index &gt; this.size()) &#123; throw new RuntimeException(&quot;索引越界&quot;); &#125; int count = 1; DNode node = head.next; while(node.next!=null) &#123; if(count == index) &#123; break; &#125; count++; node = node.next; &#125; return node; &#125; public class DNode&#123; String data;//数据域 DNode prior;//直接前驱 DNode next;//直接后继 public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125; public DNode getPrior() &#123; return prior; &#125; public void setPrior(DNode prior) &#123; this.prior = prior; &#125; public DNode getNext() &#123; return next; &#125; public void setNext(DNode next) &#123; this.next = next; &#125; &#125;&#125; 说明： 链表只设置了头结点属性，用于获取链表的其他任何结点； 由于每个结点都包含了prior属性，所以在插入和删除上操作更加简明。 六、静态链表与循环链表 静态链表 静态链表结点 1234class Node&#123; Object data;//数据信息 int cur;//下一个结点的下标&#125; 什么是静态链表？就是借用顺序表存储带有指向下一个结点的“指针域”，这个“指针域”被称做游标，表示当前结点的直接后继结点的下标。通过下标可直接定位到直接后继结点。 通过使用这种结构，线性表的插入和删除就不需移动元素了，仅需要修改指针即可，但是数组仍然存在扩容问题，此时查询和修改可直接通过遍历数组即可。 此时逻辑上相邻的两个元素，物理上并不一定相邻。 具体的结果说明如下图： 说明： 静态链表的存储与顺序表类似，数组的长度是固定的，当元素个数等于数组长度时，就需要扩容； 静态链表的插入和删除操作与单链表类似，查询和修改可简化为类似顺序表的操作。 循环链表 循环链表是另一种形式的链式存储结构，它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环； 通过这种结构，从表中任一结点出发均可找到表中其他结点。 其结构如下图 说明： 循环链表的操作和线性链表基本一致，差别仅在于算法中的循环条件不再试判断直接后继元素是否为null，而是判断是否等于头指针； 有时候，在循环链表中设立尾指针而不设头指针，可是某些操作简化，例如两个线性表的合并。 七、结束语 数据结构是一门研究非数值计算的程序设计问题中计算的操作对象以及他们之间的关系和操作等的学科； 数据结构的学习我将从两方面记录，一个是数据结构的特点，一个就是针对这种数据结构的各种操作(增、删、改、查等)； 这篇博客是我对数据结构学习的记录，仅此而已； 本系列博客的参考书籍https://book.douban.com/subject/2162035/ (《数据结构 C语言版》)。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://amazingdl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://amazingdl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"ElasticSearch-分布式全文搜索引擎","slug":"技术杂谈/ElasticSearch","date":"2020-10-25T00:03:20.000Z","updated":"2020-11-12T08:13:42.101Z","comments":true,"path":"2020/10/25/技术杂谈/ElasticSearch/","link":"","permalink":"https://amazingdl.github.io/2020/10/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/ElasticSearch/","excerpt":"Elaticsearch的学习笔记整理；记录了通过kibana客户端对ElasticSearch的基本操作和查询，以及通过RestHighLevelClient和Spring Data ElasticSearch客户端对ElasticSearch的操作。","text":"一、搜索1.1 数据库搜索的问题使用传统的数据库存储数据，那么会存在下述的问题： 在某些搜索业务场景下（如模糊搜索，海量数据搜索），效率极低,因为模糊搜索可能导致全表扫描。 而在海量数据下进行模糊搜索是企业中比较常见的业务需求 ， 所以只能通过全文搜索技术解决。 1.2 什么是全文搜索全文检索是利用==倒排索引==技术对需要搜索的数据进行处理，然后提供快速匹配的技术。 其实全文检索还有另外一种专业定义，先创建索引然后对索引进行搜索的过程，就是全文检索。 1.2.1 倒排索引倒排索引是一种存储数据的方式，与传统查找有很大区别： 传统查找：采用数据按行存储，查找时逐行扫描，或者根据索引查找，然后匹配搜索条件，效率较差。概括来讲是先找到文档，然后看是否匹配。查找一个10MB的word文档，大概需要3秒 倒排索引：首先对数据按列拆分存储，然后对文档中的数据分词，对词条进行索引，并记录词条在文档中出现的位置。这样查找时只要找到了词条，就找到了对应的文档。概括来讲是先找到词条，然后看看哪些文档包含这些词条。 类似于生活中的字典，如果想要获取一个字的所有信息，可通过拼音或部首获取某个字的位置，然后直接在该位置获取目标的所有信息。 1.2.2 搜索流程 用户在搜索输入框输入相要搜索的内容，比如输入”华为手机“； ElasticSearch获取搜索的信息并进行分词处理，会将输入的内容分词为”华为“和”手机“； 然后拿着这些拆分后的词去倒排索引列表中进行匹配，找到这些词对应的所有文档编号； 然后根据这些编号去文档列表中找到文档。 1.3 LuceneLucene是免费开源用于全文检索的程序工具包（API），由Apache软件基金会支持和提供。目前主流的java搜索框架都是依赖Lucene，官网：http://lucene.apache.org 二、分词器Analyzer（分词器）的作用是把一段文本中的词按规则取出所包含的所有词 中文的分词比较复杂，因为不是一个字就是一个词，而且一个词在另外一个地方就可能不是一个词，如在“帽子和服装”中，“和服”就不是一个词。对于中文分词，通常有三种方式：单字分词、二分法分词、词典分词。 2.1 单字分词就是按照中文一个字一个字地进行分词，效率比较低。如：“我们是中国人”，效果：“我”、“们”、“是”、“中”、“国”、“人”。（StandardAnalyzer就是这样） 2.2 二分法分词按两个字进行切分，把相邻的两个字组成词分解出来，效率也比较低。而且很多情况下分的词不对。如：“我们是中国人”，效果：“我们”、“们是”、“是中”、“中国”、“国人”。（CJKAnalyzer就是这样） 2.3 词库分词(IKAnalyzer)按分词算法构造词，然后去匹配已建好的词库集合，如果匹配到就切分出来成为词语。通常词库分词被认为是最理想的中文分词算法。如：“我们是中国人”，效果为：“我们”、“中国人”，”中国”。（使用极易分词的MMAnalyzer。可以使用“极易分词”，或者是“庖丁分词”分词器、IKAnalyzer）。 基本上可以把词全部分出来(经常用的分词器) 2.4 停用词和扩展词停用词：有些词在文本中出现的频率非常高。但对本文的语义产生不了多大的影响。例如英文的a、an、the、of等。或中文的”的、了、呢等”。这样的词称为停用词。停用词经常被过滤掉，不会被进行索引。在检索的过程中，如果用户的查询词中含有停用词，系统会自动过滤掉。停用词可以加快索引的速度，减少索引库文件的大小。 扩展词：就是不想让哪些词被分开，让他们分成一个词。 宏颜获水 我太难了 奥力给 使用停用词和扩展词 ext_stopword.dic为停用词的词库，词库里的词都被当作为停用词使用。 ext_dict.dic 为扩用词的词库，词库里的词都被当作为扩用词使用 三、ElasticSearch简介3.1 ElasticSearch概述Elaticsearch，简称为es， es是一个开源的==高扩展的分布式全文检索引擎==，它可以近乎实时的检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。ES使用Java开发，Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 面对海量数据，想要根据一些关键词搜索到想要的信息，只通过关系型数据库的查询来获取，不仅效率是非常低的，而且准确性也很低。 目前市面上也常使用ElasticSearch作为搜索引擎，比如：百度使用ElasticSearch作为文本数据分析，新浪使用ES 分析处理32亿条实时日志，阿里使用ES 构建挖财自己的日志采集和分析体系。 通过搜索引擎来获取用户想要搜索的信息并返回给用户。 3.2 ElasticSearch的使用场景ES使用场景一般分为2种情况： 3.2.1 已经上线的系统模块搜索功能使用数据库查询实现，但是已经出现性能问题，或者不满足产品的高亮相关度排序需求时。这种情况就会对系统的查询功能进行技术改造，转而使用全文检索，而es就是首选。改造业务流程如图： 3.2.2 系统新增加的模块产品一开始就要实现高亮相关度排序等全文检索的功能。针对这种情况，企业实现功能业务流程如图： 3.3 相关软件的安装的安装3.2.1 ElasticSearch的安装本篇博客使用6.8.0版本，而目前ElasticSearch已经更新7.9版本，但大部分内容是相同的。 环境建议使用JDK1.8及以上。 Elasticsearch分为Linux和Window版本，基于我们主要学习的是Elasticsearch的Java客户端的使用，所以我们课程中使用的是安装较为简便的Window版本，项目上线后，公司的运维人员会安装Linux版的ES供我们连接使用。 Elasticsearch的官方地址：https://www.elastic.co/cn/downloads/past-releases ElasticSearch中文社区下载地址关于ElasticSearch的东西都可以在这里下载。 下载完毕后，解压压缩包，并点击bin目录下的elasticsearch.bat启动启。 启动成功后，访问localhost:9200，并显示以下内容，则安装成功 3.2.2 集成IK分词器将解压后的压缩包放在ElasticSearch的plugins中 测试 IK分词器有两种分词模式：ik_max_word和ik_smart模式。 ik_max_word：会将文本做最细粒度的拆分 ik_smart：会做最粗粒度的拆分，智能拆分 通过发送请求： 1234567请求方式：POST请求url：http://127.0.0.1:9200/_analyze请求体：&#123; &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;南京市长江大桥&quot;&#125; 最细粒度的拆分结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;南京市&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;南京&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;市长&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;市&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;长江大桥&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 7, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 4 &#125;, &#123; &quot;token&quot;: &quot;长江&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 5, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 5 &#125;, &#123; &quot;token&quot;: &quot;大桥&quot;, &quot;start_offset&quot;: 5, &quot;end_offset&quot;: 7, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 6 &#125; ]&#125; 智能拆分结果： 123456789101112131415161718&#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;南京市&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;长江大桥&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 7, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 1 &#125; ]&#125; 添加扩展词典和停用词典 停用词：有些词在文本中出现的频率非常高。但对本文的语义产生不了多大的影响。例如英文的a、an、the、of等。或中文的”的、了、呢等”。这样的词称为停用词。停用词经常被过滤掉，不会被进行索引。在检索的过程中，如果用户的查询词中含有停用词，系统会自动过滤掉。停用词可以加快索引的速度，减少索引库文件的大小。 扩展词：就是不想让哪些词被分开，让他们分成一个词。比如上面的江大桥 南京市长江大桥 南京市，长江大桥 南京，市长，江大桥 江大桥拆分出来， 自定义扩展词库 1、进入到ElasticSerach安装路径\\plugins\\elasticsearch-analysis-ik-6.8.0\\config目录下, 新增自定义词典myext_dict.dic 输入 ：江大桥 2、将我们自定义的扩展词典文件，配置到IKAnalyzer.cfg.xml文件中 3、重启访问 1234567请求方式：POST请求url：http://127.0.0.1:9200/_analyze请求体：&#123; &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;南京市长江大桥&quot;&#125; 4、响应结果 12345678910111213141516171819202122232425&#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;南京市&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;市长&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 5, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;江大桥&quot;, &quot;start_offset&quot;: 5, &quot;end_offset&quot;: 8, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125; ]&#125; 3.2.3 安装ElasticSearch-headElasticSearch-head也是ElasticSearch的一个客户端，通过图形化界面对ElasticSearch进行相应的操作。 可在Chrome浏览器安装该插件，也可以下载相应的压缩包。 3.2.4 kinaba的安装Kibana是ElasticSearch的数据可视化和实时分析的工具，利用Elasticsearch的聚合功能，生成各种图表，如柱形图，线状图，饼图等。 下载完后解压 配置 1、进入安装目录下的config目录的kibana.yml文件 修改elasticsearch服务器的地址： 1elasticsearch.url: &quot;http://localhost:9200&quot; 2、修改kibana配置支持中文： 1i18n.locale: &quot;zh-CN&quot; 启动访问 常使用的功能 可在这里通过一些命令进行相应的操作。 四、核心概念Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。Elasticsearch比传统关系型数据库如下： 12345索引库(indexes)-------------&gt;数据库(Databases)类型(type)------------------&gt;数据表(Table)文档(Document)--------------&gt;行(Row)字段(Field)-----------------&gt;列(Columns)映射(mappings)--------------&gt;DDL创建数据库表的语句 详细说明： 概念 说明 索引库（indexes) 索引库包含一堆相关业务，结构相似的文档document数据，比如说建立一个商品product索引库，里面可能就存放了所有的商品数据。 类型（type） type是索引库中的一个逻辑数据分类，一个type下的document，都有相同的field，类似于数据库中的表。比如商品type，里面存放了所有的商品document数据。6.0版本以后一个index只能有1个type，6.0版本以前每个index里可以是一个或多个type。7.0以后，没有type这个概念了 文档（document） 文档是es中的存入索引库最小数据单元，一个document可以是一条客户数据，一条商品数据，一条订单数据，通常用JSON数据结构表示。document存在索引库下的type类型中。 字段（field） Field是Elasticsearch的最小单位。一个document里面有多个field，每个field就是一个数据字段 映射配置（mappings） 对type文档结构的约束叫做映射(mapping)，用来定义document的每个字段的约束。如：字段的数据类型、是否分词、是否索引、是否存储等特性。type是模拟mysql中的table概念。表是有结构的，也就是表中每个字段都有约束信息； 五、基本操作官方说明文档地址： https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html 实际开发中，通过客户端对ElasticSearch进行操作有五种方式： 第一类：发送http请求(RESTful风格)操作：9200端口 使用Postman发送请求直接操作。 使用ElasticSearch-head-master图形化界面插件操作 使用Elastic官方数据可视化的平台Kibana进行操作 第二类：通过Java代码操作：9300端口 Elasticsearch提供的Java API 客户端进行操作。 Spring Data ElasticSearch 持久层框架进行操作。 对ElasticSearch进行的每一个操作都是一次Http请求，通过Rest风格的请求来区分不同的请求。 以下的所有请求都是在kinaba的devtoots中进行操作的。 5.1 索引库(index)操作5.1.1 创建索引库发送请求 12# 请求方法：PUT，对应http请求:http:&#x2F;&#x2F;localhost:9200&#x2F;wuxie，注意请求类型为PUTPUT &#x2F;wuxie 响应结果 12345&#123; &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;index&quot; : &quot;wuxie&quot;&#125; “acknowledged” : true, 代表操作成功“shards_acknowledged” : true, 代表分片操作成功“index” : “wuxie” 表示创建的索引库名称 注意：创建索引库的分片数默认5片，在7.0.0之后的ElasticSearch版本中，默认分片数变为1片； 5.1.2 查询索引库发送请求 12# 请求方法GETGET &#x2F;wuxie 响应结果 123456789101112131415161718&#123; &quot;heima【索引库名】&quot; : &#123; &quot;aliases【别名】&quot; : &#123; &#125;, &quot;mappings【映射】&quot; : &#123; &#125;, &quot;settings【索引库设置】&quot; : &#123; &quot;index【索引】&quot; : &#123; &quot;creation_date【创建时间】&quot; : &quot;1573610302775&quot;, &quot;number_of_shards【索引库分片数】&quot; : &quot;5&quot;, &quot;number_of_replicas【索引库副本数】&quot; : &quot;1&quot;, &quot;uuid【唯一标识】&quot; : &quot;6Ffe20CIT76KchAcvqE6NA&quot;, &quot;version【版本】&quot; : &#123; &quot;created&quot; : &quot;6080099&quot; &#125;, &quot;provided_name【索引库名称】&quot; : &quot;wuxie&quot; &#125; &#125; &#125;&#125; 5.1.3 删除索引库发送请求 12# 请求方法：DELETEDELETE &#x2F;wuxie 响应结果 123&#123; &quot;acknowledged&quot; : true&#125; 5.2 类型(type)和映射(mapping)操作有了索引库，等于有了数据库中的database。接下来就需要索引库中的类型了，也就是数据库中的表。 创建数据库表需要设置字段约束，索引库也一样，在创建索引库的类型时，需要知道这个类型下有哪些字段，每个字段有哪些约束信息，这就叫做映射(mapping)。 5.2.1 添加映射给wuxie这个索引库添加了一个名为goods的类型，并且在类型中设置了4个字段： title：商品标题 subtitle: 商品子标题 images：商品图片 price：商品价格 发送请求 12345678910111213141516171819202122PUT /wuxie/goods/_mapping&#123; &quot;properties&quot;: &#123; &quot;title&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot; &#125;, &quot;subtitle&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot; &#125;, &quot;images&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;price&quot;:&#123; &quot;type&quot;: &quot;float&quot;, &quot;index&quot;: true &#125; &#125;&#125; 响应结果 123&#123; &quot;acknowledged&quot; : true&#125; 解释 123456789101112PUT /索引库名/_mapping/类型名称 或 索引库名/类型名称/_mapping&#123; &quot;properties&quot;: &#123; &quot;字段名称&quot;:&#123; &quot;type【类型】&quot;: &quot;类型&quot;, &quot;index【是否索引】&quot;: true, &quot;store【是否存储】&quot;: true, &quot;analyzer【分析器】&quot;: &quot;分词器&quot; &#125; ... &#125;&#125; 类型名称：就是前面将的type的概念，类似于数据库中的表字段名：任意填写，下面指定许多属性，例如： type：类型，Elasticsearch中支持的数据类型非常丰富，说几个关键的： String类型，又分两种： text：可分词 keyword：不可分词，数据会作为完整字段进行匹配 Numerical：数值类型，分两类 基本数据类型：long、interger、short、byte、double、float、half_float 浮点数的高精度类型：scaled_float Date：日期类型 Array：数组类型 Object：对象 index：是否索引，默认为true，也就是说你不进行任何配置，所有字段都会被索引。 true：字段会被索引，则可以用来进行搜索。默认值就是true false：字段不会被索引，不能用来搜索 store：是否将数据进行独立存储，默认为false 原始的文本会存储在_source里面，默认情况下其他提取出来的字段都不是独立存储的，是从_source里面提取出来的。当然你也可以独立的存储某个字段，只要设置store:true即可，获取独立存储的字段要比从_source中解析快得多，但是也会占用更多的空间，所以要根据实际业务需求来设置，默认为false。 analyzer：分词器，这里的ik_max_word即使用ik分词器 5.2.2 查看映射发送请求 1GET /wuxie/goods/_mapping 响应结果 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;wuxie&quot; : &#123; &quot;mappings&quot; : &#123; &quot;goods&quot; : &#123; &quot;properties&quot; : &#123; &quot;image&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;index&quot; : false &#125;, &quot;images&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;fields&quot; : &#123; &quot;keyword&quot; : &#123; &quot;type&quot; : &quot;keyword&quot;, &quot;ignore_above&quot; : 256 &#125; &#125; &#125;, &quot;name&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;analyzer&quot; : &quot;ik_max_word&quot; &#125;, &quot;price&quot; : &#123; &quot;type&quot; : &quot;float&quot; &#125;, &quot;subtitle&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;analyzer&quot; : &quot;ik_max_word&quot; &#125;, &quot;title&quot; : &#123; &quot;type&quot; : &quot;text&quot;, &quot;analyzer&quot; : &quot;ik_max_word&quot; &#125; &#125; &#125; &#125; &#125;&#125; 5.2.3 一次创建索引库及配置映射(常用)发送请求 123456789101112131415161718192021222324252627PUT /wuxie&#123; &quot;settings&quot;: &#123;&#125;, &quot;mappings&quot;: &#123; &quot;goods&quot;:&#123; &quot;properties&quot;: &#123; &quot;title&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot; &#125;, &quot;subtitle&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot; &#125;, &quot;images&quot;:&#123; &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: false &#125;, &quot;price&quot;:&#123; &quot;type&quot;: &quot;float&quot;, &quot;index&quot;: true &#125; &#125; &#125; &#125;&#125; 响应结果 12345&#123; &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;index&quot; : &quot;heima1&quot;&#125; 请求内容解释 1234567891011121314151617PUT /&#123;索引库名称&#125;&#123; &quot;settings【设置】&quot;: &#123;&#125;, &quot;mappings【映射】&quot;: &#123; &quot;&#123;类型名称&#125;&quot;:&#123; &quot;properties&quot;: &#123; &quot;title&quot;:&#123; &quot;type【类型】&quot;: &quot;text&quot;, &quot;index【是否索引】&quot;: true, &quot;store【是否存储】&quot;: true, &quot;analyzer【分析器】&quot;: &quot;ik_max_word&quot; &#125; ... &#125; &#125; &#125;&#125; 5.3 文档操作文档，即索引库中某个类型下的数据，会根据规则创建索引，将来用来搜索。可以类比做数据库中的每一行数据。 如果不指定id，会随机生成一个字符串作为id。 5.3.1 新增文档发送请求 123456789101112131415# 随机idPOST /wuxie/goods&#123; &quot;title&quot;:&quot;小米手机&quot;, &quot;images&quot;:&quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot;:2699.00&#125;# 指定idPOST /wuxie/goods/1&#123; &quot;title&quot;:&quot;小米手机&quot;, &quot;images&quot;:&quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot;:2699.00&#125; 响应结果 1234567891011121314&#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;EwVLY24BL4R5dXuhZ--1&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1&#125; 响应结果解释 1234567891011121314&#123; &quot;_index【索引库】&quot; : &quot;heima&quot;, &quot;_type【类型】&quot; : &quot;goods&quot;, &quot;_id【主键id】&quot; : &quot;EwVLY24BL4R5dXuhZ--1&quot;, &quot;_version【版本，每次对该文档操作都会自增1】&quot; : 1, &quot;result【操作结果，可以是updated、deleted】&quot; : &quot;created&quot;, &quot;_shards【分片】&quot; : &#123; &quot;total【总数】&quot; : 2, &quot;successful【成功】&quot; : 1, &quot;failed【失败】&quot; : 0 &#125;, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1&#125; 可以看到结果显示为：created，是创建成功了。 另外，需要注意的是，在响应结果中有个_id字段，这个就是这条文档数据的唯一标示，以后的增删改查都依赖这个id作为唯一标示。可以看到id的值为：EwVLY24BL4R5dXuhZ–1，这里我们新增时没有指定id，所以是ES帮我们随机生成的id。 5.3.2 查看文档根据rest风格，新增是put，查询是get(post也可以用来做查询)，不过查询一般都需要条件，这里我们把刚刚生成数据的id带上。 发送请求 1GET /wuxie/goods/EwVLY24BL4R5dXuhZ--1 响应结果 1234567891011121314&#123; &quot;_index【索引库】&quot; : &quot;wuxie&quot;, &quot;_type【类型】&quot; : &quot;goods&quot;, &quot;_id【主键id】&quot; : &quot;EwVLY24BL4R5dXuhZ--1&quot;, &quot;_version【版本】&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found【查询结果】&quot; : true, &quot;_source【源文档信息】&quot; : &#123; &quot;title&quot; : &quot;小米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 2699.0 &#125;&#125; _source：源文档信息，所有的数据都在里面。 _id：这条文档的唯一标示 found：查询结果，返回true代表查到，false代表没有 5.3.3 修改文档同新增请求相同，如果主键已存在则会将原有内容覆盖。 发送请求 123456POST /wxuie/goods/1&#123; &quot;title&quot;:&quot;超米手机&quot;, &quot;images&quot;:&quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot;:3899.00&#125; 响应结果 1234567891011121314&#123; &quot;_index&quot; : &quot;wxuie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 2, &quot;result&quot; : &quot;updated&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 1, &quot;_primary_term&quot; : 1&#125; 注意：更新后的result为updated，就代表修改成功。且每修改一次version自增1。 5.3.4 删除文档删除一个文档也不会立即从磁盘上移除，它只是被标记成已删除。Elasticsearch将会在你之后添加更多索引的时候才会在后台进行删除内容的清理。 发送请求 1DELETE /wuxie/goods/1 响应结果 1234567891011121314&#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 3, &quot;result&quot; : &quot;deleted&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 2, &quot;_primary_term&quot; : 1&#125; 可以看到result结果是：deleted，数据被删除。如果删除不存在的问题，result：not_found 根据条件删除 发送请求：根据查询的条件删除，这里的查询会在后面讲述。 12345678POST /wuxie/_delete_by_query&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;title&quot;:&quot;小米&quot; &#125; &#125;&#125; 响应结果 1234567891011121314151617&#123; &quot;took【耗时】&quot; : 58, &quot;timed_out&quot; : false, &quot;total【总数】&quot; : 2, &quot;deleted【删除总数】&quot; : 2, &quot;batches&quot; : 1, &quot;version_conflicts&quot; : 0, &quot;noops&quot; : 0, &quot;retries&quot; : &#123; &quot;bulk&quot; : 0, &quot;search&quot; : 0 &#125;, &quot;throttled_millis&quot; : 0, &quot;requests_per_second&quot; : -1.0, &quot;throttled_until_millis&quot; : 0, &quot;failures&quot; : [ ]&#125; 5.4 批量操作Bulk 操作是将文档的增删改查一些列操作，通过一次请求全都做完。减少网络传输次数。相当于，将多个新增、修改、删除的请求写到一次请求当中。 注意：bulk的请求体与其他的请求体稍有不同！ 请求语法 123456POST /wuxie/goods/_bulk&#123; action: &#123; metadata &#125;&#125;\\n&#123; request body &#125;\\n&#123; action: &#123; metadata &#125;&#125;\\n&#123; request body &#125;\\n... 语法解析： 每行一定要以换行符(\\n)结尾，包括最后一行 action/metadata 部分，指定做什么操作 action代表操作的动作，必须是如下的动作之一 create：如果文档不存在，那么就创建 index：创建一个新的文档或者替换现有文档 update：部分更新文档 delete：删除一个文档，这种操作不带请求体 metadata，是文档的元数据，包括索引(_index)，类型(_type)，id(_id)…等 request body 请求体，正常的新增文档的请求体内容(注意，不要带换行符) 隔离：每个操作互不影响。操作失败的行会返回其失败信息。 实际用法：bulk请求一次不要太大，否则积压到内存中，性能会下降。所以，一次请求几千个操作、大小控制在5M-15M之间正好。 案例 发送请求 1234567891011POST /wuxie/goods/_bulk&#123;&quot;index&quot;:&#123;&quot;_index&quot; : &quot;wuxie&quot;,&quot;_type&quot; : &quot;goods&quot;&#125;&#125;&#123;&quot;title&quot;:&quot;大米手机&quot;,&quot;images&quot;:&quot;http://image.leyou.com/12479122.jpg&quot;,&quot;price&quot;:3288&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot; : &quot;wuxie&quot;,&quot;_type&quot; : &quot;goods&quot;&#125;&#125;&#123;&quot;title&quot;:&quot;小米手机&quot;,&quot;images&quot;:&quot;http://image.leyou.com/12479122.jpg&quot;,&quot;price&quot;:2699&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot; : &quot;wuxie&quot;,&quot;_type&quot; : &quot;goods&quot;&#125;&#125;&#123;&quot;title&quot;:&quot;小米电视4A&quot;,&quot;images&quot;:&quot;http://image.leyou.com/12479122.jpg&quot;,&quot;price&quot;:4288&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot; : &quot;wuxie&quot;,&quot;_type&quot; : &quot;goods&quot;&#125;&#125;&#123;&quot;title&quot;: &quot;华为手机&quot;,&quot;images&quot;: &quot;http://image.leyou.com/12479122.jpg&quot;,&quot;price&quot;: 5288,&quot;subtitle&quot;: &quot;小米&quot;&#125;&#123;&quot;index&quot;:&#123;&quot;_index&quot; : &quot;wuxie&quot;,&quot;_type&quot; : &quot;goods&quot;&#125;&#125;&#123;&quot;title&quot;:&quot;apple手机&quot;,&quot;images&quot;:&quot;http://image.leyou.com/12479122.jpg&quot;,&quot;price&quot;:5899.00&#125; 注意： 请求体的内容不要换行 请注意 delete 动作不能有请求体 谨记最后一个换行符不要落下。 响应结果 123456789101112131415161718192021222324&#123; &quot;took&quot; : 41, &quot;errors&quot; : false, &quot;items&quot; : [ &#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;FFTEhm4BO0vjk-su75eC&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;status&quot; : 201 &#125; &#125; ... ]&#125; 每个子请求都是独立执行，因此某个子请求的失败不会对其他子请求的成功与否造成影响。 如果其中任何子请求失败，最顶层的 error 标志被设置为 true ，并且在相应的请求报告出错误明细。 status属性：代表响应状态码 六、请求头查询Elasticsearch提供了一个基于JSON的，在请求体内编写查询语句的查询方式。称之为请求体查询。 Elasticsearch 使用它以简单的 JSON接口来展现 Lucene 功能的绝大部分。这种查询语言相对于使用晦涩难懂的查询字符串的方式，更灵活、更精确、易读和易调试。 这种查询还有一种称呼：Query DSL (Query Domain Specific Language)，领域特定语言。 6.1 基本查询6.1.1 查询所有(match_al)发送请求 123456789101112131415161718POST /wuxie/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125;请求方法：POST请求地址：http://127.0.0.1:9200/索引库名/_searchPOST /&#123;索引库&#125;/_search&#123; &quot;query&quot;:&#123; &quot;查询类型&quot;:&#123; &quot;查询条件&quot;:&quot;查询条件值&quot; &#125; &#125;&#125; 这里的query代表一个查询对象，里面可以有不同的查询属性 查询类型： 例如：match_all(代表查询所有)， match，term ， range 等等 查询条件：查询条件会根据类型的不同，写法也有差异 响应结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; &quot;took【查询花费时间，单位毫秒】&quot; : 1, &quot;timed_out【是否超时】&quot; : false, &quot;_shards【分片信息】&quot; : &#123; &quot;total【总数】&quot; : 5, &quot;successful【成功】&quot; : 5, &quot;skipped【忽略】&quot; : 0, &quot;failed【失败】&quot; : 0 &#125;, &quot;hits【搜索命中结果】&quot; : &#123; &quot;total【命中总数】&quot; : 3, &quot;max_score【所有查询结果中，文档的最高得分】&quot; : 1.0, &quot;hits【命中结果集合】&quot; : [ &#123; &quot;_index【索引库】&quot; : &quot;wuxie&quot;, &quot;_type【类型】&quot; : &quot;goods&quot;, &quot;_id【主键】&quot; : &quot;ADWoZ24Bx8DA1HO-R9DD&quot;, &quot;_score【当前结果匹配得分】&quot; : 1.0, &quot;_source【源文档信息】&quot; : &#123; &quot;title&quot; : &quot;小米电视4A&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 4288 &#125; &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;_zWoZ24Bx8DA1HO-R8_D&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 2699 &#125; &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;_jWoZ24Bx8DA1HO-R8_D&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;大米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 3288&#125;&#125;]&#125;&#125; 6.1.2 匹配查询(match)match类型查询，会把查询条件进行分词，然后进行查询，多个词条之间是or的关系 发送请求 12345678POST /wuxie/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;小米手机&quot; &#125; &#125;&#125; 响应结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; &quot;took&quot; : 5, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 3, &quot;max_score&quot; : 0.5753642, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;_zWoZ24Bx8DA1HO-R8_D&quot;, &quot;_score&quot; : 0.5753642, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 2699 &#125; &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;ADWoZ24Bx8DA1HO-R9DD&quot;, &quot;_score&quot; : 0.2876821, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米电视4A&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 4288 &#125; &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;_jWoZ24Bx8DA1HO-R8_D&quot;, &quot;_score&quot; : 0.2876821, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;大米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 3288 &#125; &#125; ] &#125;&#125; 在上面的案例中，不仅会查询到电视，而且与小米相关的都会查询到。某些情况下，我们需要更精确查找，我们希望这个关系变成and，可以这样做： 发送请求： 本例中，只有同时包含小米和手机的词条才会被搜索到。 1234567891011POST /wuxie/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &#123; &quot;query【查询匹配的内容】&quot;: &quot;小米手机&quot;, &quot;operator【查询的关键词之间的关系，默认是or，如小米手机被分为小米和手机，如果是or就会查询title包含小米或手机的文档】&quot;: &quot;and&quot; &#125; &#125; &#125;&#125; 响应结果 123456789101112131415161718192021222324252627&#123; &quot;took&quot; : 4, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 1, &quot;max_score&quot; : 0.5753642, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;_zWoZ24Bx8DA1HO-R8_D&quot;, &quot;_score&quot; : 0.5753642, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 2699 &#125; &#125; ] &#125;&#125; 6.1.3 多字段匹配查询(multi_match)multi_match与match类似，不同的是它可以在多个字段中查询。 发送请求： 本例中，我们在title字段和subtitle字段中查询小米这个词 123456789POST /wuxie/_search&#123; &quot;query&quot;: &#123; &quot;multi_match&quot;: &#123; &quot;query&quot;: &quot;小米&quot;, &quot;fields&quot;: [&quot;title&quot;,&quot;subtitle&quot;] #设置查询的多个字段 &#125; &#125;&#125; 响应结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; &quot;took&quot;: 3, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: 3, &quot;max_score&quot;: 0.6099695, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;wuxie&quot;, &quot;_type&quot;: &quot;goods&quot;, &quot;_id&quot;: &quot;qfHnLG4BWrjRrOzL8Ywa&quot;, &quot;_score&quot;: 0.6099695, &quot;_source&quot;: &#123; &quot;title&quot;: &quot;小米电视4A&quot;, &quot;images&quot;: &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot;: 4288 &#125; &#125;, &#123; &quot;_index&quot;: &quot;wuxie&quot;, &quot;_type&quot;: &quot;goods&quot;, &quot;_id&quot;: &quot;qvHyLG4BWrjRrOzL9Yzn&quot;, &quot;_score&quot;: 0.2876821, &quot;_source&quot;: &#123; &quot;title&quot;: &quot;华为手机&quot;, &quot;images&quot;: &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot;: 5288, &quot;subtitle&quot;: &quot;小米&quot; #该文档的title并不包含小米关键词，而subtitle却有该关键词，所以也在查询结果中 &#125; &#125;, &#123; &quot;_index&quot;: &quot;wuxie&quot;, &quot;_type&quot;: &quot;goods&quot;, &quot;_id&quot;: &quot;qPHnLG4BWrjRrOzL3Yxl&quot;, &quot;_score&quot;: 0.2876821, &quot;_source&quot;: &#123; &quot;title&quot;: &quot;小米手机&quot;, &quot;images&quot;: &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot;: 2699 &#125; &#125; ] &#125;&#125; 6.1.4 关键词精确查询(term)term查询，精确的关键词匹配查询，不对象查询条件进行分词 发送请求 12345678910POST /wuxie/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;title&quot;: &#123; # 设置映射时，这个字段是text，且&quot;analyzer&quot;: &quot;ik_max_word&quot; &quot;value&quot;: &quot;小米&quot; &#125; &#125; &#125;&#125; 响应结果 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 2, &quot;max_score&quot; : 0.6931472, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;CzXDZ24Bx8DA1HO-nNDZ&quot;, &quot;_score&quot; : 0.6931472, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 2699 &#125; &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;DDXDZ24Bx8DA1HO-nNDZ&quot;, &quot;_score&quot; : 0.2876821, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米电视4A&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 4288 &#125; &#125; ] &#125;&#125; 6.1.5 多关键词精确查询(terms)terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件，类似于mysql的in 发送请求 123456789# 查询价格为2699或4288的商品POST /wuxie/_search&#123; &quot;query&quot;: &#123; &quot;terms&quot;: &#123; &quot;price&quot;: [2699,4288] &#125; &#125;&#125; 响应结果 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 2, &quot;max_score&quot; : 0.6931472, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;CzXDZ24Bx8DA1HO-nNDZ&quot;, &quot;_score&quot; : 0.6931472, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 2699 &#125; &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;DDXDZ24Bx8DA1HO-nNDZ&quot;, &quot;_score&quot; : 0.2876821, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米电视4A&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 4288 &#125; &#125; ] &#125;&#125; 6.2 结果过滤默认情况下，elasticsearch在搜索的结果中，会把文档中保存在_source的所有字段都返回。如果我们只想获取其中的部分字段，我们可以添加_source的过滤。 6.2.1 指定字段发送请求 12345678910# 指定查询结果中，只显示title和price两个字段POST /wuxie/_search&#123; &quot;_source&quot;: [&quot;title&quot;,&quot;price&quot;], &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;price&quot;: 2699 &#125; &#125;&#125; 响应结果 123456789101112131415161718192021222324252627282930313233343536&#123; &quot;took&quot; : 8, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 2, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;fuvESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;price&quot; : 4288, &quot;title&quot; : &quot;小米电视4A&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;fevESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;price&quot; : 2699, &quot;title&quot; : &quot;小米手机&quot; &#125; &#125; ] &#125;&#125; 6.2.2 过滤指定字段：includes和excludes我们也可以通过： includes：来指定想要显示的字段 excludes：来指定不想要显示的字段 二者都是可选的。 发送请求 1234567891011POST /wuxie/_search&#123; &quot;_source&quot;: &#123; &quot;excludes&quot;:[&quot;title&quot;,&quot;price&quot;] # 查询结果不显示title和price &#125;, &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;price&quot;: 2699 &#125; &#125;&#125; 响应结果 12345678910111213141516171819202122232425262728293031323334&#123; &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 2, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;fuvESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;fevESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot; &#125; &#125; ] &#125;&#125; 6.3 高级查询6.3.1 布尔组合(bool)bool把各种其它查询通过must（必须 ）、must_not（必须不）、should（应该）的方式进行组合 发送请求 12345678910post /wuxie/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; &quot;must&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;小米&quot; &#125;&#125;, &quot;must_not&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;电视&quot; &#125;&#125;, &quot;should&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;手机&quot; &#125;&#125; &#125; &#125;&#125; 响应结果 123456789101112131415161718192021222324252627&#123; &quot;took&quot;: 11, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: 1, &quot;max_score&quot;: 0.5753642, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;wuxie&quot;, &quot;_type&quot;: &quot;goods&quot;, &quot;_id&quot;: &quot;qPHnLG4BWrjRrOzL3Yxl&quot;, &quot;_score&quot;: 0.5753642, &quot;_source&quot;: &#123; &quot;title&quot;: &quot;小米手机&quot;, &quot;images&quot;: &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot;: 2699 &#125; &#125; ] &#125;&#125; 6.3.2 范围查询(range)range 查询找出那些落在指定区间内的数字或者时间。range查询允许以下字符： 操作符 说明 gt == (greater than) 大于&gt; gte == (greater than equal) 大于等于&gt;= lt == (less than) 小于&lt; lte == (less than equal) 小于等于&lt;= 发送请求 123456789# 查询价格大于等于2699，且小于4000元的所有商品。POST /wuxie/_search&#123; &quot;query&quot;: &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123;&quot;gte&quot;: 2699,&quot;lt&quot;: 4000&#125; &#125; &#125;&#125; 响应结果 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 2, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;CjXDZ24Bx8DA1HO-nNDZ&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;大米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 3288 &#125; &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;CzXDZ24Bx8DA1HO-nNDZ&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 2699 &#125; &#125; ] &#125;&#125; 6.3.3 模糊查询(fuzzy)fuzzy自动将拼写错误的搜索文本，进行纠正，纠正以后去尝试匹配索引中的数据。它允许用户搜索词条与实际词条出现偏差，但是偏差的编辑距离不得超过2： 修改偏差值：搜索关键词的偏差，默认就是2，我们可以通过fuzziness修改。 发送请求 1234567891011POST /wuxie/_search&#123; &quot;query&quot;: &#123; &quot;fuzzy&quot;: &#123; &quot;title&quot;: &#123; &quot;value&quot;: &quot;applaa&quot;, &quot;fuzziness&quot;: 2 &#125; &#125; &#125;&#125; 响应结果 123456789101112131415161718192021222324252627&#123; &quot;took&quot; : 26, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 1, &quot;max_score&quot; : 0.6814182, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;gOvESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 0.6814182, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;apple手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 5899.0 &#125; &#125; ] &#125;&#125; 6.4 查询排序sort 可以让我们按照不同的字段进行排序，并且通过order指定排序的方式。desc降序，asc升序。 发送请求 假定我们想要结合使用 price和 _score（得分） 进行查询，并且匹配的结果首先按照价格排序，然后按照相关性得分排序 12345678910POST /wuxie/_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123;&#125; &#125;, &quot;sort&quot;: [ &#123; &quot;price&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;, &#123; &quot;_score&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125; ]&#125; 响应结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&#123; &quot;took&quot; : 11, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 8, &quot;max_score&quot; : null, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;fevESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 2699 &#125;, &quot;sort&quot; : [ 2699.0, 1.0 ] &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;gevGSXUBkhVKNdm-jtYz&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;OPPO手机&quot;, &quot;images&quot; : &quot;http://www.baidu.com/1.jpg&quot;, &quot;price&quot; : &quot;3288.00&quot; &#125;, &quot;sort&quot; : [ 3288.0, 1.0 ] &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;fOvESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;大米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 3288 &#125;, &quot;sort&quot; : [ 3288.0, 1.0 ] &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;guvGSXUBkhVKNdm-jtYz&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;VIVO手机&quot;, &quot;images&quot; : &quot;http://www.baidu.com/31.jpg&quot;, &quot;price&quot; : &quot;3288.00&quot; &#125;, &quot;sort&quot; : [ 3288.0, 1.0 ] &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;g-vGSXUBkhVKNdm-jtYz&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;一加手机&quot;, &quot;images&quot; : &quot;http://www.baidu.com/21.jpg&quot;, &quot;price&quot; : &quot;3288.00&quot; &#125;, &quot;sort&quot; : [ 3288.0, 1.0 ] &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;fuvESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米电视4A&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 4288 &#125;, &quot;sort&quot; : [ 4288.0, 1.0 ] &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;f-vESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;华为手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 5288, &quot;subtitle&quot; : &quot;小米&quot; &#125;, &quot;sort&quot; : [ 5288.0, 1.0 ] &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;gOvESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;apple手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 5899.0 &#125;, &quot;sort&quot; : [ 5899.0, 1.0 ] &#125; ] &#125;&#125; 6.5 高亮查询什么是高亮显示：在进行关键字搜索时，搜索出的内容中的关键字会显示不同的颜色，称之为高亮。 ElasticSearch可以对查询内容中的关键字部分，进行标签和样式(高亮)的设置。 在使用match查询的同时，加上一个highlight属性： pre_tags：前置标签 post_tags：后置标签 fields：需要高亮的字段 title：这里声明title字段需要高亮，后面可以为这个字段设置特有配置，也可以空 发送请求 12345678910111213141516# 高亮 查询POST /wuxie/goods/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;小米&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;pre_tags&quot;: &quot;&lt;font sytle=&#x27;color:red;&#x27;&gt;&quot;, &quot;post_tags&quot;: &quot;&lt;/font&gt;&quot;, &quot;fields&quot;: &#123; &quot;title&quot;: &#123;&#125; &#125; &#125;&#125; 响应结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;took&quot; : 49, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 2, &quot;max_score&quot; : 0.8142733, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;fuvESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 0.8142733, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米电视4A&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 4288 &#125;, &quot;highlight&quot; : &#123; &quot;title&quot; : [ &quot;&lt;font sytle=&#x27;color:red;&#x27;&gt;小米&lt;/font&gt;电视4A&quot; ] &#125; &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;fevESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 0.2876821, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;小米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 2699 &#125;, &quot;highlight&quot; : &#123; &quot;title&quot; : [ &quot;&lt;font sytle=&#x27;color:red;&#x27;&gt;小米&lt;/font&gt;手机&quot; # 此时返回的关键词使用hightlight被tags包裹了 ] &#125; &#125; ] &#125;&#125; 6.6 分页查询发送请求 12345678POST /wuxie/goods/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;from&quot;: 1, &quot;size&quot;: 5&#125; size：每页显示多少条 from：当前页的起始索引，int from = (当前页 - 1) * 每页条数 响应结果 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;took&quot; : 0, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 8, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;gevGSXUBkhVKNdm-jtYz&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;OPPO手机&quot;, &quot;images&quot; : &quot;http://www.baidu.com/1.jpg&quot;, &quot;price&quot; : &quot;3288.00&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;wuxie&quot;, &quot;_type&quot; : &quot;goods&quot;, &quot;_id&quot; : &quot;fOvESXUBkhVKNdm-E9bF&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;title&quot; : &quot;大米手机&quot;, &quot;images&quot; : &quot;http://image.leyou.com/12479122.jpg&quot;, &quot;price&quot; : 3288 &#125; &#125; ] &#125;&#125; 七、高级Rest客户端7.1 环境搭建相关依赖 123456789101112131415161718&lt;!--elasticsearch的高级别rest客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;6.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--elasticsearch的rest客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-client&lt;/artifactId&gt; &lt;version&gt;6.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--elasticsearch的核心jar包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;6.8.0&lt;/version&gt;&lt;/dependency&gt; 将RestHighLevelClient对象注入Spring容器 12345678910111213141516171819@Configuration@ConfigurationProperties(prefix = &quot;elasticsearch&quot;)@Componentpublic class ElasticSearchConfig &#123; private String host; private Integer port; //初始化RestHighLevelClient，将该对象注入IOC容器 @Bean(destroyMethod = &quot;close&quot;)//销毁时调用close方法 public RestHighLevelClient client() &#123; //RestClient客户端构建器对象 RestClientBuilder restClientBuilder = RestClient.builder(new HttpHost(host, port, &quot;http&quot;)); //操作es的高级rest客户端对象 RestHighLevelClient restHighLevelClient = new RestHighLevelClient(restClientBuilder); return restHighLevelClient; &#125; //getter ,setter,toString..省略&#125; 配置主机和端口号 1234# es服务地址elasticsearch.host=127.0.0.1# es服务端口elasticsearch.port=9200 7.2 操作索引库7.2.1 创建索引库12345678910111213141516171819@Testpublic void createIndex() throws IOException &#123; //1.创建请求对象，创建索引的请求 CreateIndexRequest indexRequest = new CreateIndexRequest(&quot;test&quot;); //获取的是索引的客户端对象，可以对索引进行新增、删除、查询、配置映射等操作 IndicesClient indicesClient = client.indices(); //2.客户端发送请求，获取响应对象； // 第一个参数是请求对象，第二个参数是当前请求对象的配置（包括请求头、响应内容大小及异常的回调方法） CreateIndexResponse response = indicesClient.create(indexRequest, RequestOptions.DEFAULT); //3.显示响应结果信息 System.out.println(&quot;index:&quot;+response.index()); System.out.println(&quot;acknowledged:&quot;+response.isAcknowledged()); //4.关闭客户端 client.close();&#125; 发送请求中，传入请求对象的同时还设置了一个RequestOptions对象的静态成员变量DEFAULT。其含义是，配置当前请求选项为默认值。 其中RequestOptions对象的作用是用来配置请求，主要配置项目有请求头，缓冲区大小(默认100M)，异常处理器(warningsHandler)。默认情况下，缓冲区大小100MB，请求头及异常处理器为空。 7.2.2 查看索引库12345678910111213141516171819@Testpublic void getIndex() throws IOException &#123; //创建请求对象，查询索引的请求 GetIndexRequest request = new GetIndexRequest(&quot;test&quot;); //获取操作索引的对象 IndicesClient indicesClient = client.indices(); //根据请求对象，执行索引的操作 GetIndexResponse response = indicesClient.get(request, RequestOptions.DEFAULT); //查看响应信息 System.out.println(response.getAliases()); System.out.println(response.getMappings()); System.out.println(response.getSettings()); //关闭客户端，由于配置了bean在销毁时调用close方法，所以可省略&#125; 7.2.3 删除索引库1234567@Testpublic void deleteIndex() throws IOException &#123; DeleteIndexRequest request = new DeleteIndexRequest(&quot;test&quot;); IndicesClient indices = client.indices(); AcknowledgedResponse response = indices.delete(request, RequestOptions.DEFAULT); System.out.println(response.isAcknowledged());//返回删除结果&#125; 7.3 操作映射7.3.1 创建映射RestHighLevelClient配置映射，与kibana略有区别。在客户端中配置映射，不支持设置类型type。不设置type，并不代表没有，而是默认的type为_doc。 第一种方式 12345678910111213141516171819202122232425262728293031323334353637383940//创建映射信息@Testpublic void putMapping() throws IOException &#123; //创建请求对象：索引、类型 //索引库的名称传入构造函数 //类型默认值，在6.8.0版本中是不支持设置类型的，默认类型是_doc PutMappingRequest mappingRequest = new PutMappingRequest(&quot;test&quot;); //构建请求体 XContentBuilder jsonBuilder = XContentFactory.jsonBuilder(); jsonBuilder.startObject() .startObject(&quot;properties&quot;) .startObject(&quot;title&quot;) .field(&quot;type&quot;,&quot;text&quot;).field(&quot;analyzer&quot;,&quot;ik_max_word&quot;) .endObject() .startObject(&quot;subtitle&quot;) .field(&quot;type&quot;,&quot;text&quot;).field(&quot;analyzer&quot;,&quot;ik_max_word&quot;) .endObject() .startObject(&quot;category&quot;) .field(&quot;type&quot;,&quot;keyword&quot;) .endObject() .startObject(&quot;brand&quot;) .field(&quot;type&quot;,&quot;keyword&quot;) .endObject() .startObject(&quot;images&quot;) .field(&quot;type&quot;,&quot;keyword&quot;).field(&quot;index&quot;,false) .endObject() .startObject(&quot;price&quot;) .field(&quot;type&quot;,&quot;float&quot;) .endObject() .endObject() .endObject(); mappingRequest.source(jsonBuilder);//将请求体封装到请求中 AcknowledgedResponse response = client.indices().putMapping(mappingRequest, RequestOptions.DEFAULT); System.out.println(response.isAcknowledged());&#125; 第二种方式 12345678910111213141516171819/** *目标：配置映射。第二种方式，使用JSON字符串 * 1.创建请求对象：配置映射 * 设置索引库name * 设置配置映射请求体 * 2.客户端发送请求，获取响应对象 * 3.打印响应结果 */@Testpublic void putMappingMethodTwo() throws IOException &#123; //1.创建请求对象：配置映射 PutMappingRequest request = new PutMappingRequest(&quot;test&quot;); //设置请求体，source(&quot;请求体json字符串&quot;，&quot;请求体的数据类型&quot;); request.source(&quot;&#123;\\&quot;properties\\&quot;:&#123;\\&quot;title\\&quot;:&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;analyzer\\&quot;:\\&quot;ik_max_word\\&quot;&#125;,\\&quot;subtitle\\&quot;:&#123;\\&quot;type\\&quot;:\\&quot;text\\&quot;,\\&quot;analyzer\\&quot;:\\&quot;ik_max_word\\&quot;&#125;,\\&quot;category\\&quot;:&#123;\\&quot;type\\&quot;:\\&quot;keyword\\&quot;&#125;,\\&quot;brand\\&quot;:&#123;\\&quot;type\\&quot;:\\&quot;keyword\\&quot;&#125;,\\&quot;price\\&quot;:&#123;\\&quot;type\\&quot;:\\&quot;float\\&quot;&#125;,\\&quot;images\\&quot;:&#123;\\&quot;type\\&quot;:\\&quot;keyword\\&quot;,\\&quot;index\\&quot;:false&#125;&#125;&#125;&quot;, XContentType.JSON); //2.客户端发送请求，获取响应对象 AcknowledgedResponse response = client.indices().putMapping(request, RequestOptions.DEFAULT); //3.打印响应结果 System.out.println(&quot;acknowledged::&quot;+response.isAcknowledged());&#125; 7.3.2 查看映射12345678910//查看映射信息@Testpublic void getMapping() throws IOException &#123; GetMappingsRequest request = new GetMappingsRequest(); //设置索引库name request.indices(&quot;test&quot;); GetMappingsResponse response = client.indices().getMapping(request, RequestOptions.DEFAULT); System.out.println(response.mappings().get(&quot;test&quot;).sourceAsMap());&#125; 7.4 文档操作实体类 12345678910111213141516import lombok.Builder;import lombok.Data;@Data@Builder//构建者模式创建Goods对象public class Goods &#123; private Long id;//商品的唯一标识 private String title;//标题 private String subtitle;//子标题 private String category;//分类 private String brand;//品牌 private Double price;//价格 private String images;//图片地址&#125; 7.4.1 新增文档1234567891011121314151617181920212223242526272829303132333435//新增文档@Testpublic void postDocument() throws IOException &#123; //创建索引库对象(IndexRequest)，封装索引、映射及主键id信息 //String id = UUID.randomUUID().toString(); IndexRequest indexRequest = new IndexRequest().index(&quot;test&quot;).type(&quot;_doc&quot;); //创建请求体，三种方式 //1、使用字符串 //2、通过对象构造JSON字符串 Goods goods = Goods.builder() .id(1L) .images(&quot;http://www.baidu.com/1.jpg&quot;) .price(3666.00) .title(&quot;小米手机&quot;) .category(&quot;手机&quot;) .brand(&quot;小米&quot;).build(); //3、在source中写入key-value参数 //indexRequest.source(XContentType.JSON,&quot;title&quot;,&quot;小米手机&quot;,&quot;brand&quot;,&quot;小米&quot;); ObjectMapper objectMapper = new ObjectMapper(); String requestBody = objectMapper.writeValueAsString(goods); indexRequest.source(requestBody, XContentType.JSON); IndexResponse response = client.index(indexRequest, RequestOptions.DEFAULT); //3.打印响应结果 System.out.println(&quot;_index：：&quot;+response.getIndex()); System.out.println(&quot;_type：：&quot;+response.getType()); System.out.println(&quot;_id：：&quot;+response.getId()); System.out.println(&quot;result：：&quot;+response.getResult());&#125; 7.4.2 修改文档根据id修改文档内容，与新增请求相同，如果存在该id，则修改该id的内容 12345678910111213141516//修改文档@Testpublic void updateDocument() throws IOException &#123; //修改文档必须传入id值，此id是唯一标识,是ElasticSearch随机生成的，不同于映射中的id UpdateRequest updateRequest = new UpdateRequest().index(&quot;test&quot;).type(&quot;_doc&quot;).id(&quot;r4NFWHUB6yUL1DAm1kGm&quot;); updateRequest.doc(XContentType.JSON,&quot;id&quot;,&quot;2&quot;,&quot;title&quot;,&quot;华为手机&quot;,&quot;brand&quot;,&quot;华为&quot;); UpdateResponse response = client.update(updateRequest, RequestOptions.DEFAULT); //3.打印响应结果 System.out.println(&quot;_index：：&quot;+response.getIndex()); System.out.println(&quot;_type：：&quot;+response.getType()); System.out.println(&quot;_id：：&quot;+response.getId()); System.out.println(&quot;result：：&quot;+response.getResult());&#125; 7.4.3 查询文档12345678910111213//根据id查询文档@Testpublic void getDocumentById() throws IOException &#123; GetRequest getRequest = new GetRequest().index(&quot;test&quot;).type(&quot;_doc&quot;).id(&quot;r4NFWHUB6yUL1DAm1kGm&quot;); GetResponse response = client.get(getRequest,RequestOptions.DEFAULT); //3.打印响应结果 System.out.println(&quot;_index：：&quot;+response.getIndex()); System.out.println(&quot;_type：：&quot;+response.getType()); System.out.println(&quot;_id：：&quot;+response.getId()); System.out.println(&quot;_source：：&quot;+response.getSourceAsString());&#125; 7.4.4 删除文档12345678910111213//删除文档@Testpublic void deleteDocument() throws IOException &#123; DeleteRequest deleteRequest = new DeleteRequest().index(&quot;test&quot;).type(&quot;_doc&quot;).id(&quot;sINVWHUB6yUL1DAmFkF4&quot;); DeleteResponse response = client.delete(deleteRequest, RequestOptions.DEFAULT); //3.打印响应结果 System.out.println(&quot;_index：：&quot;+response.getIndex()); System.out.println(&quot;_type：：&quot;+response.getType()); System.out.println(&quot;_id：：&quot;+response.getId()); System.out.println(&quot;_result：：&quot;+response.getResult());&#125; 7.4.5 文档的批量操作批量新增文档 123456789101112131415161718192021222324252627282930313233//批量添加文档@Testpublic void addBulkDocument() throws IOException &#123; BulkRequest bulkRequest = new BulkRequest(); IndexRequest request1 = new IndexRequest() .index(&quot;test&quot;) .type(&quot;_doc&quot;) .id(&quot;1&quot;) .source(XContentType.JSON, &quot;brand&quot;, &quot;小米&quot;, &quot;title&quot;, &quot;小米手机&quot;); IndexRequest request2 = new IndexRequest() .index(&quot;test&quot;) .type(&quot;_doc&quot;) .id(&quot;2&quot;) .source(XContentType.JSON, &quot;brand&quot;, &quot;华为&quot;, &quot;title&quot;, &quot;华为&quot;); IndexRequest request3 = new IndexRequest() .index(&quot;test&quot;) .type(&quot;_doc&quot;) .id(&quot;3&quot;) .source(XContentType.JSON, &quot;brand&quot;, &quot;一加&quot;, &quot;title&quot;, &quot;一加手机&quot;); bulkRequest.add(request1); bulkRequest.add(request2); bulkRequest.add(request3); BulkResponse response = client.bulk(bulkRequest, RequestOptions.DEFAULT); //4.打印响应结果 System.out.println(&quot;took::&quot;+response.getTook()); System.out.println(&quot;Items::&quot;+response.getItems());&#125; 批量删除文档 12345678910111213141516//批量删除文档@Testpublic void deleteBulkDocument() throws IOException &#123; BulkRequest bulkRequest = new BulkRequest(); bulkRequest.add(new DeleteRequest().index(&quot;test&quot;).type(&quot;_doc&quot;).id(&quot;1&quot;)); bulkRequest.add(new DeleteRequest().index(&quot;test&quot;).type(&quot;_doc&quot;).id(&quot;2&quot;)); bulkRequest.add(new DeleteRequest().index(&quot;test&quot;).type(&quot;_doc&quot;).id(&quot;3&quot;)); BulkResponse response = client.bulk(bulkRequest, RequestOptions.DEFAULT); //4.打印响应结果 System.out.println(&quot;took::&quot;+response.getTook()); System.out.println(&quot;Items::&quot;+response.getItems());&#125; 7.5 基本查询7.5.1 匹配查询(matchAll)12345678910111213141516171819202122232425262728293031@Testpublic void queryAll() throws IOException &#123; //1.创建请求对象 SearchRequest request = new SearchRequest().indices(&quot;wuxie&quot;).types(&quot;goods&quot;); //2.创建查询请求体构建器 SearchSourceBuilder builder = new SearchSourceBuilder(); //QueryBuilders类包含了大部分的请求体查询静态方法，且方法名包含查询语句的关键字 builder.query(QueryBuilders.matchAllQuery()); //设置请求体 request.source(builder); //3.客户端发送请求，获取响应对象 SearchResponse response = client.search(request, RequestOptions.DEFAULT); //4.打印响应结果 SearchHits hits = response.getHits(); System.out.println(&quot;took::&quot;+response.getTook()); System.out.println(&quot;time_out::&quot;+response.isTimedOut()); System.out.println(&quot;total::&quot;+hits.getTotalHits()); System.out.println(&quot;max_score::&quot;+hits.getMaxScore()); System.out.println(&quot;&lt;----hits:&quot;); for (SearchHit hit : hits) &#123; String sourceAsString = hit.getSourceAsString(); System.out.println(sourceAsString); &#125; System.out.println(&quot;----&gt;&quot;);&#125; 7.5.2 匹配查询(match)12345678910111213141516171819202122232425262728293031323334@Testpublic void matchQuery() throws IOException &#123; //1.创建请求对象：匹配查询 SearchRequest request = new SearchRequest(); request.types(&quot;goods&quot;); request.indices(&quot;wuxie&quot;); //2.创建查询请求体构建器 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //匹配查询，设置分词后关键词的查询关系，默认是or MatchQueryBuilder matchQueryBuilder = QueryBuilders.matchQuery(&quot;title&quot;, &quot;小米手机&quot;) .operator(Operator.AND); sourceBuilder.query(matchQueryBuilder); //设置请求体 request.source(sourceBuilder); //3.客户端发送请求，获取响应对象 SearchResponse response = client.search(request, RequestOptions.DEFAULT); //4.打印响应结果 printResult(response);&#125;//打印结果信息public void printResult(SearchResponse response) &#123; SearchHits hits = response.getHits(); System.out.println(&quot;took::&quot;+response.getTook()); System.out.println(&quot;time_out::&quot;+response.isTimedOut()); System.out.println(&quot;total::&quot;+hits.getTotalHits()); System.out.println(&quot;max_score::&quot;+hits.getMaxScore()); System.out.println(&quot;&lt;----hits:&quot;); for (SearchHit hit : hits) &#123; String sourceAsString = hit.getSourceAsString(); System.out.println(sourceAsString); &#125; System.out.println(&quot;----&gt;&quot;);&#125; 7.5.3 匹配查询(multi_match)123456789101112131415161718@Testpublic void mulitMatchQuery() throws IOException &#123; //1.创建请求对象 SearchRequest request = new SearchRequest(); request.types(&quot;goods&quot;); request.indices(&quot;wuxie&quot;); //2.创建查询请求体构建器 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //设置查询方式：多字段匹配查询，第一个参数是条件，以后的参数都是字段 MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(&quot;小米&quot;, &quot;title&quot;, &quot;subtitle&quot;); sourceBuilder.query(multiMatchQueryBuilder); //设置请求体 request.source(sourceBuilder); //3.客户端发送请求，获取响应对象 SearchResponse response = client.search(request, RequestOptions.DEFAULT); //4.打印响应结果 printResult(response);&#125; 7.5.4 关键词精确匹配查询(term)1234567891011121314151617@Testpublic void termQuery() throws IOException &#123; //1.创建请求对象 SearchRequest request = new SearchRequest(); request.types(&quot;goods&quot;); request.indices(&quot;wuxie&quot;); //2.创建查询请求体构建器 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //设置查询方式：关键词精确查询 sourceBuilder.query(QueryBuilders.termQuery(&quot;title&quot;, &quot;小米&quot;)); //设置请求体 request.source(sourceBuilder); //3.客户端发送请求，获取响应对象 SearchResponse response = client.search(request, RequestOptions.DEFAULT); //4.打印响应结果 printResult(response);&#125; 7.5.5 多关键词精确匹配查询(terms)1234567891011121314151617@Testpublic void termsQuery() throws IOException &#123; //1.创建请求对象 SearchRequest request = new SearchRequest(); request.types(&quot;goods&quot;); request.indices(&quot;wuxie&quot;); //2.创建查询请求体构建器 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //设置查询方式：多关键词精确查询 sourceBuilder.query( QueryBuilders.termsQuery(&quot;title&quot;, &quot;手机&quot;, &quot;小米&quot;)); //设置请求体 request.source(sourceBuilder); //3.客户端发送请求，获取响应对象 SearchResponse response = client.search(request, RequestOptions.DEFAULT); //4.打印响应结果 printResult(response);&#125; 7.6 结果过滤、排序和分页设置过滤、排序和分页实在SourceBuilder中构建的，而上面的查询条件是在query方法中通过QueryBuilders的方法中构建的。 1234567891011121314151617181920212223242526272829@Testpublic void includesSources() throws IOException &#123; //1.创建请求对象 SearchRequest request = new SearchRequest(); request.types(&quot;goods&quot;); request.indices(&quot;wuxie&quot;); //2.创建查询请求体构建器 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //设置查询方式 sourceBuilder.query(QueryBuilders.matchAllQuery()); //设置过滤条件，包含和排除 String[] includes = &#123;&quot;title&quot;,&quot;price&quot;,&quot;images&quot;&#125;; String[] excludes = &#123;&quot;images&quot;&#125;; sourceBuilder.fetchSource(includes,excludes); //设置排序 FieldSortBuilder sortBuilder = SortBuilders.fieldSort(&quot;price&quot;); //设置排序降序 sortBuilder.order(SortOrder.DESC); sourceBuilder.sort(sortBuilder); //设置分页 sourceBuilder.from(0);//当前页起始索引 sourceBuilder.size(5);//每页显示多少条 //设置请求体 request.source(sourceBuilder); //3.客户端发送请求，获取响应对象 SearchResponse response = client.search(request, RequestOptions.DEFAULT); //4.打印响应结果 printResult(response);&#125; 7.7 高级查询7.7.1 布尔查询(bool)注意布尔查询在请求体构建中使用的是BoolQueryBuilder对象。 12345678910111213141516171819202122232425@Testpublic void boolQuery() throws IOException &#123; //1.创建请求对象 SearchRequest request = new SearchRequest(); request.types(&quot;goods&quot;); request.indices(&quot;wuxie&quot;); //2.创建查询请求体构建器 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //构建查询方式：布尔查询 BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); //必须包含小米 boolQueryBuilder.must(QueryBuilders.matchQuery(&quot;title&quot;,&quot;小米&quot;)); //必须不含电视 boolQueryBuilder.mustNot(QueryBuilders.matchQuery(&quot;title&quot;,&quot;电视&quot;)); //应该含有手机 boolQueryBuilder.should(QueryBuilders.matchQuery(&quot;title&quot;,&quot;手机&quot;)); //设置查询方式 sourceBuilder.query(boolQueryBuilder); //设置请求体 request.source(sourceBuilder); //3.客户端发送请求，获取响应对象 SearchResponse response = client.search(request, RequestOptions.DEFAULT); //4.打印响应结果 printResult(response);&#125; 7.7.2 范围查询(range)此时使用的请求体构建器是RangeQueryBuilder对象。 1234567891011121314151617181920212223@Testpublic void rangeQuery() throws IOException &#123; //1.创建请求对象 SearchRequest request = new SearchRequest(); request.types(&quot;goods&quot;); request.indices(&quot;wuxie&quot;); //2.创建查询请求体构建器 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //构建查询方式：范围查询 RangeQueryBuilder rangeQueryBuilder = QueryBuilders.rangeQuery(&quot;price&quot;); //大于2千 rangeQueryBuilder.gt(2000); //小于4千 rangeQueryBuilder.lt(4000); //设置查询方式 sourceBuilder.query(rangeQueryBuilder); //设置请求体 request.source(sourceBuilder); //3.客户端发送请求，获取响应对象 SearchResponse response = client.search(request, RequestOptions.DEFAULT); //4.打印响应结果 printResult(response);&#125; 7.7.3 模糊查询(fuzzy)此时使用的请求体构建器是SearchSourceBuilder对象。 12345678910111213141516171819@Testpublic void fuzzyQuery() throws IOException &#123; //1.创建请求对象 SearchRequest request = new SearchRequest().types(&quot;goods&quot;).indices(&quot;wuxie&quot;); //2.创建查询请求体构建器 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //构建查询方式：模糊查询 FuzzyQueryBuilder fuzzyQueryBuilder = QueryBuilders.fuzzyQuery(&quot;title&quot;, &quot;appla&quot;); //设置偏差值 fuzzyQueryBuilder.fuzziness(Fuzziness.ONE); //设置查询方式 sourceBuilder.query(fuzzyQueryBuilder); //设置请求体 request.source(sourceBuilder); //3.客户端发送请求，获取响应对象 SearchResponse response = client.search(request, RequestOptions.DEFAULT); //4.打印响应结果 printResult(response);&#125; 7.7.4 高亮查询(Highlighter)此时使用的请求体构建器是HighlightBuilder对象，并使用QueryBuilders进行条件查询，查询结果字段中的关键词高亮。 此时设置请求体构建器的方法是highlighter()。 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void highLighterQuery() throws IOException &#123; //1.创建请求对象 SearchRequest request = new SearchRequest().types(&quot;goods&quot;).indices(&quot;wuxie&quot;); //2.创建查询请求体构建器 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //构建查询方式：高亮查询 //设置查询方式 sourceBuilder.query(QueryBuilders.termsQuery(&quot;title&quot;, &quot;小米&quot;);); //构建高亮字段 HighlightBuilder highlightBuilder = new HighlightBuilder(); highlightBuilder.preTags(&quot;&lt;font color=&#x27;red&#x27;&gt;&quot;);//设置标签前缀 highlightBuilder.postTags(&quot;&lt;/font&gt;&quot;);//设置标签后缀 highlightBuilder.field(&quot;title&quot;);//设置高亮字段 //设置高亮构建对象 sourceBuilder.highlighter(highlightBuilder); //设置请求体 request.source(sourceBuilder); //3.客户端发送请求，获取响应对象 SearchResponse response = client.search(request, RequestOptions.DEFAULT); //4.打印响应结果 SearchHits hits = response.getHits(); System.out.println(&quot;took::&quot;+response.getTook()); System.out.println(&quot;time_out::&quot;+response.isTimedOut()); System.out.println(&quot;total::&quot;+hits.getTotalHits()); System.out.println(&quot;max_score::&quot;+hits.getMaxScore()); System.out.println(&quot;hits::::&gt;&gt;&quot;); for (SearchHit hit : hits) &#123; String sourceAsString = hit.getSourceAsString(); System.out.println(sourceAsString); //打印高亮结果 Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields(); System.out.println(highlightFields); &#125; System.out.println(&quot;&lt;&lt;::::&quot;);&#125; 八、Spring Data ElasticSearch8.1 简介Spring Data是一个用于==简化持久层数据访问==的开源框架。其主要目标是使得对数据的访问变得方便快捷。 Spring Data可以极大的简化数据操作的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。包括CRUD外，还包括如分页、排序等一些常用的功能，几乎可以节省持久层代码80%以上的编码工作量。 Spring Data ElasticSearch 基于 spring data API 简化 elasticSearch操作，将原始操作elasticSearch的客户端API 进行封装 。Spring Data为Elasticsearch项目提供集成搜索引擎。Spring Data Elasticsearch POJO的关键功能区域为中心的模型与Elastichsearch交互文档和轻松地编写一个存储库数据访问层。 使用时一定要注意版本问题，ElasticSearch 6.x与ElasticSearch 7.x的区别还是很大的 而且Spring Data ElasticSearch的高版本是支持ElasticSearch 7.x的。 本文Spring Data ElasticSearch 使用的版本是2.1.9 8.2 环境搭建8.2.1 依赖123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; 8.2.2 创建实体类123456789public class Good &#123; private Long id;//商品的唯一标识 private String title;//标题 private String category;//分类 private String brand;//品牌 private Double price;//价格 private String images;//图片地址 //getter，setter，toString&#125; 8.2.3 编写配置文件1234# 配置集群名称spring.data.elasticsearch.cluster-name=elasticsearch# 配置es的服务地址spring.data.elasticsearch.cluster-nodes=127.0.0.1:9300 8.3 常用操作几个用到的注解： @Document：声明索引库配置 indexName：索引库名称 type：类型名称，默认是“docs” shards：分片数量，默认5 replicas：副本数量，默认1 @Id：声明实体类的id @Field：声明字段属性 type：字段的数据类型 analyzer：指定分词器类型 index：是否创建索引 默认为true store:是否存储 默认为false 12345678910111213141516171819202122232425262728293031/** * 商品实体类 * @Document() 注解作用：定义一个索引库，一个类型 * indexName属性：指定索引库的名称 * type属性：指定类型名称 * shards属性：指定分片数 * replicas属性：指定复制副本数 */@Document(indexName = &quot;data&quot;,type = &quot;goods&quot;,shards = 5,replicas = 1)public class Goods &#123; //必须有id,这里的id是全局唯一的标识,等同于es中的“_id” @Id private Long id; /** * type: 字段数据类型 * analyzer: 分词器类型 * index: 是否索引(默认值：true) * store: 是否存储(默认值：false) */ @Field(type = FieldType.Text,analyzer = &quot;ik_max_word&quot;) private String title;//标题 @Field(type = FieldType.Keyword) private String category;//分类 @Field(type = FieldType.Keyword) private String brand;//品牌 @Field(type = FieldType.Double) private Double price;//价格 @Field(type = FieldType.Keyword,index = false) private String images;//图片地址 &#125; 8.3.1 操作索引库1234567891011121314151617181920212223242526272829303132333435@RunWith(SpringRunner.class)//此版本需要加入该注解导入Spring容器@SpringBootTestpublic class IndexOperation &#123; @Autowired ElasticsearchTemplate elasticsearchTemplate; @Test public void createIndex()&#123; //创建索引 boolean data = elasticsearchTemplate.createIndex(Goods.class); System.out.println(data); //配置映射 boolean result = elasticsearchTemplate.putMapping(Goods.class); System.out.println(result); &#125; @Test public void deleteIndex()&#123; //删除索引 boolean deleteIndex = elasticsearchTemplate.deleteIndex(Goods.class); System.out.println(deleteIndex); &#125; @Test public void getInfo()&#123; //获取映射信息 Map mapping = elasticsearchTemplate.getMapping(Goods.class); System.out.println(mapping.get(&quot;properties&quot;)); &#125;&#125; 8.3.2 文档的增删改查创建dao层类 123456/** * 继承持久层接口的ElasticSearch的模板接口 * ElasticsearchRepository&lt;映射对应的类名,主键类型&gt; */public interface GoodDao extends ElasticsearchRepository&lt;Goods,Long&gt; &#123; &#125; 方法说明 12345678910111213141516171819202122//新增文档Goods save(Goods var1);//批量新增文档Iterable&lt;Goods&gt; saveAll(Iterable&lt;Goods&gt; var1);//根据id查找文档Optional&lt;Goods&gt; findById(Long var1);//判断某个文档是否存在boolean existsById(Long var1);//查询所有文档Iterable&lt;Goods&gt; findAll();//根据id查询文档Iterable&lt;Goods&gt; findAllById(Iterable&lt;Long&gt; var1);//文档数量long count();//根据id删除文档void deleteById(Long var1);//删除某个文档，可以根据其他属性，不一定是idvoid delete(Goods var1);//批量删除文档void deleteAll(Iterable&lt;Goods&gt; var1);//删除索引文档void deleteAll(); 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringdataEsGoodCRUD &#123; //注入Good业务层实现类 @Autowired private GoodDao goodDao; /** * 新增 */ @Test public void save()&#123; Good good = new Good(); good.setId(1l); good.setTitle(&quot;小米手机&quot;); good.setCategory(&quot;手机&quot;); good.setBrand(&quot;小米&quot;); good.setPrice(19999.0); good.setImages(&quot;http://image.leyou.com/12479122.jpg&quot;); goodDao.save(good); &#125; //修改 @Test public void update()&#123; Good good = new Good(); good.setId(1l); good.setTitle(&quot;小米手机&quot;); good.setCategory(&quot;手机&quot;); good.setBrand(&quot;小米&quot;); good.setPrice(9999.0); good.setImages(&quot;http://image.leyou.com/12479122.jpg&quot;); goodDao.save(good); &#125; //删除 @Test public void delete()&#123; Good good = new Good(); good.setId(1l); goodDao.delete(good); &#125; //根据id查询 @Test public void findById()&#123; Good good = goodDao.findById(2l).get(); System.out.println(good); &#125; //查询所有 @Test public void findAll()&#123; Iterable&lt;Good&gt; goods = goodDao.findAll(); for (Good good : goods) &#123; System.out.println(good); &#125; &#125; //批量新增 @Test public void saveAll()&#123; List&lt;Good&gt; goodList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; Good good = new Good(); good.setId((long) i); good.setTitle(&quot;[&quot;+i+&quot;]小米手机&quot;); good.setCategory(&quot;手机&quot;); good.setBrand(&quot;小米&quot;); good.setPrice(19999.0+i); good.setImages(&quot;http://image.leyou.com/12479122.jpg&quot;); goodList.add(good); &#125; goodDao.saveAll(goodList); &#125; //分页查询 @Test public void findByPageable()&#123; //设置排序(排序方式，正序还是倒序，排序的id) Sort sort = new Sort(Sort.Direction.DESC,&quot;id&quot;); int currentPage=2;//当前页 int pageSize = 100;//每页显示多少条 //设置查询分页 PageRequest pageRequest = PageRequest.of(currentPage, pageSize,sort); //分页查询 Page&lt;Good&gt; goodPage = goodDao.findAll(pageRequest); for (Good good : goodPage.getContent()) &#123; System.out.println(good); &#125; &#125;&#125; 8.3.3 Search查询ElasticSearch的search方法中QueryBuilders，就是查询对象构建对象QueryBuilders。QueryBuilders具备的能力，search方法都具备。所以大致查询方式类似。 都是主要QueryBuilders构建想要的查询，然后通过GoodsDao类的search方法查询。 123456789101112131415161718192021222324252627282930313233343536@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringdataEsSearch &#123; //注入Goods业务层实现类 @Autowired private GoodsDao goodsDao; /** * term查询 * search(termQueryBuilder) 调用搜索方法，参数查询构建器对象 */ @Test public void termQuery()&#123; TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;title&quot;, &quot;小米&quot;); Iterable&lt;Goods&gt; goods = goodsDao.search(termQueryBuilder); for (Goods g : goods) &#123; System.out.println(g); &#125; &#125; /** * term查询加分页 */ @Test public void termQueryByPage()&#123; int currentPage= 0 ; int pageSize = 5; //设置查询分页 PageRequest pageRequest = PageRequest.of(currentPage, pageSize); TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;title&quot;, &quot;小米&quot;); Iterable&lt;Goods&gt; goods = goodsDao.search(termQueryBuilder,pageRequest); for (Good g : goods) &#123; System.out.println(g); &#125; &#125;&#125; 8.3.4 自定义查询GoodsRepository提供了非常强大的自定义查询功能；只要遵循SpringData提供的语法，我们可以任意定义方法声明； 查询语法：findBy+字段名+Keyword+字段名+…. Keyword Sample Elasticsearch Query String And findByNameAndPrice &#123;&quot;bool&quot; : &#123;&quot;must&quot; : [ &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;, &#123;&quot;field&quot; : &#123;&quot;price&quot; : &quot;?&quot;&#125;&#125; ]&#125;&#125; Or findByNameOrPrice &#123;&quot;bool&quot; : &#123;&quot;should&quot; : [ &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;, &#123;&quot;field&quot; : &#123;&quot;price&quot; : &quot;?&quot;&#125;&#125; ]&#125;&#125; Is findByName &#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;&#125;&#125; Not findByNameNot &#123;&quot;bool&quot; : &#123;&quot;must_not&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;&#125;&#125; Between findByPriceBetween &#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : ?,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125; Before findByPriceBefore &#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125; After findByPriceAfter &#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;range&quot; : &#123;&quot;price&quot; : &#123;&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true&#125;&#125;&#125;&#125;&#125; Like findByNameLike &#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &#123;&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true&#125;&#125;&#125;&#125;&#125; StartingWith findByNameStartingWith &#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &#123;&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true&#125;&#125;&#125;&#125;&#125; EndingWith findByNameEndingWith &#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &#123;&quot;query&quot; : &quot;*?&quot;,&quot;analyze_wildcard&quot; : true&#125;&#125;&#125;&#125;&#125; In findByNameIn(Collection&lt;String&gt;names) &#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;bool&quot; : &#123;&quot;should&quot; : [ &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;, &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125; ]&#125;&#125;&#125;&#125; NotIn findByNameNotIn(Collection&lt;String&gt;names) &#123;&quot;bool&quot; : &#123;&quot;must_not&quot; : &#123;&quot;bool&quot; : &#123;&quot;should&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;&#125;&#125;&#125;&#125; OrderBy findByNameOrderByNameDesc &#123;&quot;sort&quot; : [&#123; &quot;name&quot; : &#123;&quot;order&quot; : &quot;desc&quot;&#125; &#125;],&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?&quot;&#125;&#125;&#125; dao层接口 123456789101112131415/** * ElasticsearchRepository 持久层操作ElasticSearch的模板接口 */public interface GoodsDao extends ElasticsearchRepository&lt;Goods,Long&gt; &#123; /** * 根据title和价格查询，and的关系 */ List&lt;Goods&gt; findAllByTitleAndPrice(String title,Double price); /** * 根据商品价格范围查询 * 最低价格lowPrice * 最高价格highPrice */ List&lt;Goods&gt; findByPriceBetween(Double lowPrice,Double highPrice);&#125; 测试 1234567891011121314151617181920212223242526272829303132333435363738/** * 自定义方法名称查询测试类 */@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringdataEsCustomMethodQuery &#123; //注入Goods业务层实现类 @Autowired private GoodsDao goodsDao; /** * 根据标题及价格查询 * 要求价格等于20023且标题的内容包含小米关键词 */ @Test public void findAllByTitleAndPrice()&#123; String title = &quot;小米&quot;; Double price = 20023.0; List&lt;Goods&gt; goods = goodDao.findAllByTitleAndPrice(title, price); for (Goods g : goods) &#123; System.out.println(g); &#125; &#125; /** * 根据价格范围查询 * 要求商品价格再3000，到20000之间 */ @Test public void findPriceBetween()&#123; double lowPrice = 3000.0;//最低价 double highPrice = 20000.0;//最高价 List&lt;Goods&gt; goods = goodDao.findByPriceBetween(lowPrice, highPrice); for (Goods g : goods) &#123; Systemout.println(g); &#125; &#125;&#125; 九、结束语 本篇博客使用ElasticSearch的版本是6.8，包括客户端对应的版本都是基于6.x的； 本篇博客只是对于ElasticSearch的简单使用，并未涉及到太过复杂的内容； 详细官方文档地址：https://www.elastic.co/guide/index.html","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://amazingdl.github.io/categories/NoSQL/"}],"tags":[{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://amazingdl.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"}]},{"title":"Java SE之类与对象","slug":"Java基础/Java SE之类与对象","date":"2020-10-13T16:00:00.000Z","updated":"2020-10-27T00:03:54.746Z","comments":true,"path":"2020/10/14/Java基础/Java SE之类与对象/","link":"","permalink":"https://amazingdl.github.io/2020/10/14/Java%E5%9F%BA%E7%A1%80/Java%20SE%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"当人们尝试描述这个世界的时候，他们会把所有的事物进行归类，具有相同属性的归为一类，从而更好的认识这个世界；当计算机想要认识这个世界的时候，它也用了相同的方法。","text":"一、面向对象程序设计概念一切都是对象 从面向对象程序设计讲到Java中的面向对象思想 什么是面向过程设计 什么是面向对象设计 什么是类 什么是对象 Java面向对象思想中加入了接口 面向对象程序设计三大特性：封装、继承和多态 二、自定义类使用Java创建一个自己的类 三、类的封装通过阐述类的属性、方法、构造器、内部类、代码块等结构来说明一个类的构成 static this 类的封装性 四、接口与抽象类接口：多实现，只有抽象方法和静态属性的 抽象类：单继承 六、继承与多态所有的父类Object super关键字 重写 继承与实现等内容 七、其他包括包装类、权限修饰符、API的使用等 八、结束语","categories":[{"name":"Java","slug":"Java","permalink":"https://amazingdl.github.io/categories/Java/"}],"tags":[{"name":"Java SE","slug":"Java-SE","permalink":"https://amazingdl.github.io/tags/Java-SE/"},{"name":"面向对象","slug":"面向对象","permalink":"https://amazingdl.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Java SE之基本语法","slug":"Java基础/Java SE之基本语法","date":"2020-09-01T06:27:46.000Z","updated":"2020-10-26T23:53:26.697Z","comments":true,"path":"2020/09/01/Java基础/Java SE之基本语法/","link":"","permalink":"https://amazingdl.github.io/2020/09/01/Java%E5%9F%BA%E7%A1%80/Java%20SE%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"Java基本语法的总结和回顾，从数据类型、运算符到流程控制相关的知识点汇众，既是总结，亦是回顾。","text":"一、前言​ 同其他编程语言一样，Java也有自己的数据类型、运算符、流程控制等基本的语法；通过简单的判断和循环就能够完成复杂的算法，从而解决各种各样的问题。 ​ 即使各种编程语言的思想大致相同，但每种编程语言的部分细节却又不尽相同，所以基本的语法和细节还是值得注意和警惕的。 ​ 就如同其他编程语言一样，即使Java是面向对象的一门编程语言，Java也需要基本的数据类型、运算符和流程控制等基础的语法，因此，本篇博客就是总结和回顾一些我在学习Java时的一些基础语法知识，是对以前知识的回顾、总结，并希望通过本篇文章进一步加深我对Java的理解和对编程的理解。 二、数据类型​ Java的数据类型包括基本数据类型和引用数据类型，其中基本数据类型包括四类八种，分别是byte、short、int、long、float、double、char和boolean。 整数 类型 占用存储空间 范围 byte 1字节 -128~127 short 2字节 -32 768 - 32 767 int 4字节 -2 147 483 648 - 2 147 483 647 long 8字节 -9 223 372 036 854 775 808 - 9 223 372 036 854 775 807 注意： 长整型数值有一个后缀L或 l； 即二进制是以0b/0B开头；八进制是以数字0开头；十六进制是以0X/0x开头，此时的a-f不区分大小写。 浮点数 类型 占用存储空间 范围 float 4字节 大约± 3.402 823 47E+38F (有效位数为 6 ~ 7 位） double 8字节 大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位） 注意： float 类型的数值有一个后缀F或 f (例如，3.14F。) 没有后缀F 的浮点数值（如 3.14 ) 默认为double 类型。 double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值)。绝大部分应用程序都采用double类型。 浮点数值不适用于无法接受舍入误差的金融计算中。 例如，命令 System.out.println( 2.0-1.1 ) 将打印出 0.8999999999999999, 而不是人们想象的0.9。 字符 类型 占用存储空间 char 2字节 Unicode 不同的地区有不同的编码机制；于是就产生了问题：一个是对于任意给定的代码值，在不同的编码方案下有可能对应不同的字母；二是采用大字符集的语言其编码长度有可能不同。 常见的编码机制：美国的 ASCII、 西欧语言中的ISO 8859-1 俄罗斯的 KOI-8、 中国的 GB 18030 和 BIG-5。 然而，两个字节的代码宽度足以对世界上各种语言的所有字符进行编码， 并有足够的空间留给未来的扩展。 在设计 Java 时决定采用 16 位的 Unicode 字符集，这样会比使用 8 位字符集的程序设计语言有很大的改进。 在 Java 中，char 类型描述了 UTF-16 编码中的一个代码单兀。我们强烈建议不要在程序中使用 char 类型，除非确实需要处理 UTF-16 代码单元。最好将字符串作为抽象数据类型处理。 常见的字符转义序列 转义序列 名称 unicode值 \\b 退格 \\u0008 \\t 制表 \\u0009 \\n 换行 \\u000a \\r 回车 \\u000d \\ “ 双引号 \\u0022 \\ ‘ 单引号 \\u0027 \\ \\ 反斜杠 \\u005c 常用字符与ASCII代码对照表 ASCII码 键盘 ASCII 码 键盘 ASCII 码 键盘 ASCII 码 键盘 27 ESC 32 SPACE 33 ! 34 “ 35 # 36 $ 37 % 38 &amp; 39 ‘ 40 ( 41 ) 42 * 43 + 44 ‘ 45 - 46 . 47 / 48 0 49 1 50 2 51 3 52 4 53 5 54 6 55 7 56 8 57 9 58 : 59 ; 60 &lt; 61 = 62 &gt; 63 ? 64 @ 65 A 66 B 67 C 68 D 69 E 70 F 71 G 72 H 73 I 74 J 75 K 76 L 77 M 78 N 79 O 80 P 81 Q 82 R 83 S 84 T 85 U 86 V 87 W 88 X 89 Y 90 Z 91 [ 92 \\ 93 ] 94 ^ 95 _ 96 ` 97 a 98 b 99 c 100 d 101 e 102 f 103 g 104 h 105 i 106 j 107 k 108 l 109 m 110 n 111 o 112 p 113 q 114 r 115 s 116 t 117 u 118 v 119 w 120 x 121 y 122 z 123 { 124 | 125 } 126 ~ 布尔型 boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件 整型值和布尔值之间不能进行相互转换。 三、注释、关键字与变量1. 注释单行注释 1// 单行注释 多行注释 123/* 多行注释*/ 文档注释 该注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现该程序的说明文档，类似于JDK说明文档； 通过命令可生成该文档：javadoc -d 文档名 -author -version 类名.java； 12345678910111213141516171819202122232425262728293031323334/** * 文档注释 * javadoc是用于提取注释的工具，输出的是一个HTML文件； * 文档标签和其嵌入HTML * 独立文档标签是一些以@字符开头的命令，且要置于注释行的最前面； * 行内文档标签可以出现在注释的任何地方，也是一@字符开头，但是要扩展花括号内。 * javadoc只能为public和protected成员进行文档注释。 * 嵌入HTML * &lt;h1&gt;标题&lt;/h1&gt; * &lt;ol&gt; * &lt;li&gt;Item one&lt;/li&gt; * &lt;/ol&gt; * 独立文档注释 * @see java.swing.JFrame * @version 版本 * @author 作者 * @since 最早使用的版本 * 行内文档注释 * &#123;@link java.util.Date&#125; * &#123;@docRoot &#125; 该标签产生到文档根目录的相对路径，用于文档树页面的显示超链接 */public class Test&#123; //方法上 /** * @param 参数名 方法说明 * @return 返回值描述 * @throws 对方法的异常进行说明 */ public void test()&#123; &#125;&#125; 2. 关键字和标识符特点：关键字中所有的字母都是小写； 保留字：goto和const，即Java目前尚未使用，但以后版本可能使用； 标识符：对变量、方法和类等元素命名时的字节序列。 命名规则 可使用26个英文字母的大小写，0-9，_和$组成； 数字不可以开头； 不可以使用关键字和保留字，但可以包含关键字和保留字； Java中严格区分大小写，长度无限制； 不能包含空格。 命名规范 包名：多单词组成时，所有字母都都小写； 类名、接口名：多单词组成时，所有单词的首字母大写； 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写； 常量名：所有字母都大写，多个单词时每个单词用下划线连接。 3. 变量与常量此时说明的都是局部变量或局部常量，即在一个方法内或一段代码块内声明的变量或者常量，与后面的类属性无法。 变量 在 Java 中，每个变量都有一个类型（ type)。在声明变量时，变量的类型位于变量名之前。 注意：声明一个变量之后，必须用赋值语句对变量进行显式初始化， 千万不要使用未初始化的变量。 常量 在 Java 中， 利用关键字 final 指示常量。 关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。 1final double CM_PER_INCH = 2.54; 四、运算符 基本运算符 在 Jav 中，使用算术运算符 +、-、 *、/ 表示加、减、 乘、除运算。 当参与 / 运算的两个操作数都是整数时， 表示整数除法；否则， 表示浮点除法。 整数的求余操作（有时称为取模) 用 ％ 表示，只有整数类型变量能够进行取余运算。 通常表达式中出现的最大的数据类型决定了表达式最终结果的数据类型；即如果将一个float值与一个double值相乘，结果就是double。 可以在赋值中使用二元运算符，这是一种很方便的简写形式。例如， X += 4;等价于：x = x + 4; (一般地， 要把运算符放在 = 号左边，如 *= 或 ％=)。 强制类型转换 经常需要将一种数值类型转换为另一种数值类型。但有些会造成信息丢失。 从占用存储空间小的向占用存储空间大的转换不会丢失数据类型，反之则会丢失数据类型。 特殊的 从int转换为float可能会丢失数据类型； 从long转换为double可能会丢失数据类型； 从long转换为float可能会丢失数据类型； 从int转换位double不会丢失数据类型。 运算符中的类型转换 如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。 否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。 否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 否则， 两个操作数都将被转换为 int 类型。 在char、byte和short中，对这些类型的任何一个进行算术运算，都会获得一个int类型，必须将其显示的类型转换会原来的类型，以将值赋给原本的类型； 逻辑运算符 ==(等于)、!=(不等于) &lt; (小于) 、&gt; (大于)、&lt;=(小于等于）和 &gt;= (大于等于）运算符都是逻辑元素符，其运算的结果都是布尔型。 &amp;&amp; 和 &amp;(与)：只要有一个操作数为false，结果就为false。 || 和 |(或)：只要有一个操作数为true，结果就为true。 ! (非)：对操作为去反，如果操作数为true，表达式结果为false，反之同理。 三元运算符 1条件表达式? 结果1 : 结果2 根据条件表达式返回结果；如果条件表达式结果为true，则返回结果1，否则返回结果2。 &amp;&amp; 与&amp;、||与|的区别 &amp; 称为逻辑与运算符，&amp;&amp; 称为短路与运算符，也可叫逻辑与运算符。 ​ 对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。 ​ 对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。 ​ 综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是 ​ 否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。 &amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。 位运算符 运算符 运算 示例 &lt;&lt; 左移 3&lt;&lt;2 =&gt;3 * 2 * 2=12 &gt;&gt; 右移 3&gt;&gt;1=&gt;3/2=1；结果为int类型，所以为1。 &gt;&gt;&gt; 无符号右移 3&gt;&gt;&gt;1=&gt;3/2=1 &amp; 与运算 6&amp;3=2 | 或运算 6|3=7 ^ 异或运算 6^3=5 ~ 取反运算 ~6=-7 注意： 如果堆char、byte、short类型的数字进行移位处理，那么在移位进行之前，他们会被转换为int类型，并且得到的结果也是一个int类型。 对于&amp;、|如果两个操作数或表达式是布尔类型，则进行的是逻辑运算，且如果两个操作数都是表达式都需要进行计算，无论是否影响整个表达式的最终结果。 所有的位运算都是基于二进制的，比如^运算符，如果对于6和3两个整数，其二进制分别为1010和0011，则异或的结果就是1001，也就是5。 自增与自减 12n++; // n自增1n--; // n自减1 实际上， 这些运算符有两种形式；上面介绍的是运算符放在操作数后面的“ 后缀” 形式。 还有一种“ 前缀” 形式：++n。后缀和前缀形式都会使变量值加 1 或减 1。但用在表达式中时，二者就有区别了。前缀形式会先完成加 1; 而后缀形式会使用变量原来的值。 括号与运算符级别 如果不使用圆括号， 就按照给出的运算符优先级次序进行计算。 优先级 描述 运算符 1 括号 () [] 2 正负号 + - 3 自增自减，非 ++ – ! 4 乘除，取余 * / % 5 加减 + - 6 移位运算 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 7 大小关系 &gt; &gt;= &lt; &lt;= 8 相等关系 == != 9 按位与 &amp; 10 按位异或 ^ 11 按位或 | 12 逻辑与 &amp;&amp; 13 逻辑或 || 14 条件运算 ?: 15 赋值运算 = += -= *= /= %= 16 位赋值运算 &amp;= |= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= 五、控制流程1. 条件语句1234567if(condition)&#123; &#125; else if(condition) &#123; &#125; else &#123; &#125; 与绝大多数程序设计语言一样， Java 常常希望在某个条件为真时执行多条语句。 注意：在上述中，condition可以是表达式或变量，如果是变量则必须是boolean类型，如果是表达式，表达式结果也必须是boolean类型。后面的循环语句的判断条件也是这种要求。 2. 循环语句 while 123while(condition)&#123; &#125; 满足条件进入循环，直到不满足条件退出循环。 do…while 123do&#123; &#125; while(condition) 满足条件，继续循环继续，否则退出循环，此种循环结构执行执行一次循环体。 for 123for(int i = 0;i&lt;10;i++)&#123; &#125; 执行步骤：先执行int i = 0且只执行一次；然后执行i&lt;10，结果为true时进入循环体；循环体执行完毕执行i++； 3. switch语句123456switch(n)&#123; case 1:执行语句;break; case 2:.... default:执行语句;break;&#125; case 标签可以是： 类型为 char、byte、 short 或 int 的常量表达式。 枚举常量。 从 Java SE 7开始， case 标签还可以是字符串字面量。 说明： 当n与某个case匹配是，执行该条件语句。 case的执行语句执行完毕后，如果没有break，则会继续执行下一个case，直到break，或者switch语句执行完毕。 当所有的case都不匹配时，汇之星default部分。 4. break和continue尽管 Java 的设计者将 goto 作为保留字，但实际上并没有打算在语言中使用它。 Java语言中增加了一条带标签的 break，用于中断流程控制。 例如：在无限循环中，当if条件满足时则退出循环。 1234while (true) &#123; if (condition) break;&#125; 带标签的break； 在多重循环中，可通过为循环体设置标签，然后满足一定条件时，直接退出执行的循环体；比如下面当if条件成立，就执行退出外循环了 123456outter: while () //外循环 for ()&#123; //内循环； if (condition) break outter; &#125; 还有一个 continue 语句。与 break 语句一样， 它将中断正常的控制流程。continue语句将控制转移到最内层循环的首部。 即退出本次循环，继续进行下一次循环。 12345678Scanner in = new Scanner(System.in);while (sum &lt; goal ) &#123; System.out.print(&quot;Enter a number: &quot;); n = in.nextlnt(); if (n &lt; 0) //如果输入的只为0，退出本次循环，继续进行下一次循环。 continue; sum += n;&#125; 六、数组概述 数组是一种数据结构， 用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。 在声明数组变量时， 需要指出数组类型 （ 数据元素类型紧跟 []) 和数组变量的名字。 数组的长度是固定的。 数组标识符其实只是一个引用，指向在堆中创建的一个真实对象，这个对象用以保存指向其他对象的引用。 声明数组： 一位数组的声明方式；int[] arr=new int[]{}，int[] arr=new int[10]；其中方括号也可放在变量名后面； 还可以这样声明int[] arr={1,3, }，这种初始化方式只能使用在数组定义之处； 二维数组的声明；int[] arr[]=new int [ 3 ] [ ]；外层元素的初始值为null，内层元素的值不 能调用，否则报错； 注意数组的变量名直接赋值，是把数组的首地址赋给了另一个数组，当另一个数组发生改变时，这个数组也会发生改变。 使用花括号初始化数组，初始化列表的最后一个逗号是可选的；即new int{1,23,4,}也是可以的； 案例： 1int[] array = &#123; 2, 3, 5, 7, 11, 13 &#125;; 多维数组 123int[][] array = new int[size] [size];//声明二维数组，默认值是0int[][] array = &#123; &#123;16, 3, 2, 13&#125;， &#123;5, 10, 11, 8&#125;, (9, 6, 7, 12&#125;, &#123;4, 15, 14, 1&#125; &#125;;//声明二维数组 说明：二维数组与一维数组并没有太多的不同，可以把二维数据理解为存放若干个一维数组的一维数组。 例如： 123456789101112int[] a = &#123;1,2,3&#125;;int[] b = &#123;4,5,6&#125;;int[] c = &#123;7,8,9&#125;;int[][] array = &#123;a,b,c&#125;;for(int i=0;i&lt;array.length;i++) &#123; for(int j = 0;j&lt;array[i].length;j++) &#123; System.out.print(array[i][j]+&quot;\\t&quot;); &#125; System.out.println();&#125; 更多维的数组思想类似，不过基本上用不到。 七、结束语本篇文章主要是对Java基础语法的一个小总结，可能不是很全面，但也是自己学习Java的总结。 参考书籍 Java核心技术：https://book.douban.com/subject/26880667/","categories":[{"name":"Java","slug":"Java","permalink":"https://amazingdl.github.io/categories/Java/"}],"tags":[{"name":"Java SE","slug":"Java-SE","permalink":"https://amazingdl.github.io/tags/Java-SE/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://amazingdl.github.io/categories/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://amazingdl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"中间件","slug":"中间件","permalink":"https://amazingdl.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://amazingdl.github.io/categories/NoSQL/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://amazingdl.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"数据结构","slug":"数据结构","permalink":"https://amazingdl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"消息队列","slug":"消息队列","permalink":"https://amazingdl.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://amazingdl.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"name":"Java SE","slug":"Java-SE","permalink":"https://amazingdl.github.io/tags/Java-SE/"},{"name":"面向对象","slug":"面向对象","permalink":"https://amazingdl.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]}