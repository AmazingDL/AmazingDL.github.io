<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>消息队列之RabbitMQ的简单还是用 | 无邪の博客</title>
  <meta name="description" content="MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法。在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量">
<meta property="og:type" content="article">
<meta property="og:title" content="消息队列之RabbitMQ的简单还是用">
<meta property="og:url" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/index.html">
<meta property="og:site_name" content="无邪の博客">
<meta property="og:description" content="MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法。在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq01.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq02.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq03.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq04.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq05.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq06.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq07.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq08.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq09.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq10.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq11.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq12.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq13.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq14.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq15.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq16.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq17.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq18.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq19.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq19.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq20.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq21.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq22.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq23.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq24.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq25.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq26.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq27.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq28.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq29.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq30.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq31.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq32.png">
<meta property="og:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq33.png">
<meta property="article:published_time" content="2020-11-01T06:27:46.000Z">
<meta property="article:modified_time" content="2020-11-12T08:16:53.459Z">
<meta property="article:author" content="AmazingDL">
<meta property="article:tag" content="消息队列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq01.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/index.html">
  
    <link rel="alternate" href="/atom.xml" title="无邪の博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.1.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/cofess" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">AmazingDL</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Life Explorer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Luoyang, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/AmazingDL" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://gitee.com/dl_wuxie" target="_blank" title="Gitee" data-toggle=tooltip data-placement=top><i class="icon icon-gitee"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NoSQL/">NoSQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-SE/" rel="tag">Java SE</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/" rel="tag">搜索引擎</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Java-SE/" style="font-size: 13.5px;">Java SE</a> <a href="/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/" style="font-size: 13px;">搜索引擎</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14px;">数据结构</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 13px;">消息队列</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 13px;">面向对象</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
              </p>
              <p class="item-title">
                <a href="/2020/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="title">数据结构(三)——二叉树</a>
              </p>
              <p class="item-date">
                <time datetime="2020-11-06T23:20:47.000Z" itemprop="datePublished">2020-11-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>
              </p>
              <p class="item-title">
                <a href="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/" class="title">消息队列之RabbitMQ的简单还是用</a>
              </p>
              <p class="item-date">
                <time datetime="2020-11-01T06:27:46.000Z" itemprop="datePublished">2020-11-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
              </p>
              <p class="item-title">
                <a href="/2020/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" class="title">数据结构(二)——栈和队列</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-28T00:50:50.000Z" itemprop="datePublished">2020-10-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
              </p>
              <p class="item-title">
                <a href="/2020/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="title">数据结构(一)——线性表</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-28T00:43:19.000Z" itemprop="datePublished">2020-10-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/NoSQL/">NoSQL</a>
              </p>
              <p class="item-title">
                <a href="/2020/10/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/ElasticSearch/" class="title">ElasticSearch-分布式全文搜索引擎</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-25T00:03:20.000Z" itemprop="datePublished">2020-10-25</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-技术杂谈/RabbitMQ" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      消息队列之RabbitMQ的简单还是用
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/" class="article-date">
	  <time datetime="2020-11-01T06:27:46.000Z" itemprop="datePublished">2020-11-01</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="一、消息队列概述"><a href="#一、消息队列概述" class="headerlink" title="一、消息队列概述"></a>一、消息队列概述</h2><p>MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法。</p>
<p>RabbitMQ是一个Erlang开发的AMQP（Advanced Message Queuing Protocol ）的开源实现。</p>
<h3 id="1-1-为什么使用MQ"><a href="#1-1-为什么使用MQ" class="headerlink" title="1.1 为什么使用MQ"></a>1.1 为什么使用MQ</h3><p>在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。</p>
<p>开发中消息队列通常有如下应用场景：</p>
<p>**(1) 异步提速: **</p>
<p>​    任务异步处理将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p>
<p>**(2) 应用解耦: **</p>
<p>​    应用程序解耦合，MQ充当中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合</p>
<p>**(3) 削峰填谷: **</p>
<p>​    在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用MQ能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p>
<p>**(4) 可恢复性: **</p>
<p>​    系统的一部分组件失效时，不会影响到整个系统。MQ降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p>
<p><strong>(5) 排序保证：</strong></p>
<p>​     消息队列可以控制数据处理的顺序，因为消息队列本身使用的是队列这个数据结构，<code>FIFO</code>(先进选出)，在一些场景数据处理的顺序很重要，比如商品下单顺序等。</p>
<h3 id="1-2-消息队列产品"><a href="#1-2-消息队列产品" class="headerlink" title="1.2. 消息队列产品"></a>1.2. 消息队列产品</h3><p>市场上常见的消息队列有如下：</p>
<ul>
<li>ActiveMQ：基于JMS实现, 比较均衡, 不是最快的, 也不是最稳定的.</li>
<li>ZeroMQ：基于C语言开发, 目前最好的队列系统.</li>
<li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好, 数据基本上不会丢失</li>
<li>RocketMQ：基于JMS，阿里巴巴产品, 目前已经捐献给apahce, 还在孵化器中孵化.</li>
<li>Kafka：类似MQ的产品；分布式消息系统，高吞吐量, 目前最快的消息服务器, 不保证数据完整性.</li>
</ul>
<h3 id="1-3-AMQP-和-JMS"><a href="#1-3-AMQP-和-JMS" class="headerlink" title="1.3. AMQP 和 JMS"></a>1.3. AMQP 和 JMS</h3><blockquote>
<p>Dubbo协议：Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</p>
<p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。</p>
<p>AMQP协议：即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</p>
</blockquote>
<p>MQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。</p>
<h4 id="1-3-1-AMQP"><a href="#1-3-1-AMQP" class="headerlink" title="1.3.1. AMQP"></a>1.3.1. AMQP</h4><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p>
<h4 id="1-3-2-JMS"><a href="#1-3-2-JMS" class="headerlink" title="1.3.2. JMS"></a>1.3.2. JMS</h4><p>JMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p>
<h4 id="1-3-3-AMQP-与-JMS-区别"><a href="#1-3-3-AMQP-与-JMS-区别" class="headerlink" title="1.3.3. AMQP 与 JMS 区别"></a>1.3.3. AMQP 与 JMS 区别</h4><p>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。JMS规定了两种消息模式；而AMQP的消息模式更加丰富.</p>
<table>
<thead>
<tr>
<th></th>
<th>JMS</th>
<th align="center">AMQP</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>Java api</td>
<td align="center">Wire-protocol</td>
</tr>
<tr>
<td>跨语言</td>
<td>否</td>
<td align="center">是</td>
</tr>
<tr>
<td>跨平台</td>
<td>否</td>
<td align="center">是</td>
</tr>
</tbody></table>
<h3 id="1-4-RabbitMQ"><a href="#1-4-RabbitMQ" class="headerlink" title="1.4. RabbitMQ"></a>1.4. RabbitMQ</h3><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，<strong>消息队列在分布式系统开发中应用非常广泛。</strong></p>
<p>RabbitMQ官方地址：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a></p>
<p>RabbitMQ提供了6种模式：Hello Word简单模式，work工作模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式(通配符模式)，RPC远程调用模式（远程调用，不太算MQ；不作介绍）</p>
<p>官网对应模式介绍：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p>
<p><strong>应用场景：</strong></p>
<p><strong>1、双十一商品秒杀/抢票功能实现</strong></p>
<p>我们在双11的时候，当我们凌晨大量的秒杀和抢购商品，然后去结算的时候，就会发现，界面会提醒我们，让我们稍等，以及一些友好的图片文字提醒。而不是像前几年的时代，动不动就页面卡死，报错等来呈现给用户。</p>
<p><strong>2、积分兑换(积分可用于多平台)</strong></p>
<p>积分兑换模块，有一个公司多个部门都要用到这个模块，这时候就可以通过消息队列解耦这个特性来实现。 各部门系统做各部门的事，但是他们都可以用这个积分系统进行商品的兑换等。其他模块与积分模块完全解耦。</p>
<p><strong>3、大平台用户注册</strong></p>
<p>发送邮件、用户大数据分析操作等 基于同步变异步功能实现</p>
<p>用户注册真实操作步骤：</p>
<ol>
<li>用户注册选择的兴趣标签，根据用户的属性，行为进行用户分析，计算出推荐内容</li>
<li>注册后可能需要发送邮件给用户</li>
<li>发送短信给用户</li>
<li>发送给用户指南的系统通知</li>
<li>…等等</li>
</ol>
<p><strong>正常情况注册，不出现高并发，假如有大量的用户注册，发生了高并发，就会出现如下情况</strong>：</p>
<p>邮件接口承受不住，或是分析信息时的大量计算使 cpu 满载，这将会出现虽然用户数据记录很快的添加到数据库中了，但是却卡在发邮件或分析信息时的情况，导致请求的响应时间大幅增长，甚至出现超时，这就有点不划算了。面对这种情况一般也是将这些操作放入消息队列（生产者消费者模型），消息队列慢慢的进行处理，同时可以很快的完成注册请求，不会影响用户使用其他功能。</p>
<h3 id="1-5-相关定义："><a href="#1-5-相关定义：" class="headerlink" title="1.5 相关定义："></a>1.5 相关定义：</h3><p>1.Message</p>
<p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p>
<p>2.Publisher</p>
<p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p>
<p>3.Exchange </p>
<p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。<br>4.Binding </p>
<p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。<br>5.Queue</p>
<p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。 </p>
<p>6.Connection </p>
<p>网络连接，比如一个TCP连接。 </p>
<p>7.Channel </p>
<p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP  命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP  都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p>
<p>8.Consumer </p>
<p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p>
<p>9.Virtual Host </p>
<p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个  mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP  概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。 </p>
<p>10.Broker </p>
<p>表示消息队列服务器实体。</p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq01.png"></p>
<p>==<strong>由Exchange、Queue、RoutingKey三个才能决定一个消息从Exchange到Queue的唯一的线路。</strong>==</p>
<h2 id="二、Spring-Boot整合RabbitMQ"><a href="#二、Spring-Boot整合RabbitMQ" class="headerlink" title="二、Spring Boot整合RabbitMQ"></a>二、Spring Boot整合RabbitMQ</h2><p>在spring boot项目中，只需要引入start-amqp起步依赖，即可整合RabbitMQ成功；我们基于SpringBoot封装的RabbitTemplate模板对象，可以非常方便的发送消息，接收消息(使用注解)。</p>
<p>amqp的官方GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-amqp">https://github.com/spring-projects/spring-amqp</a></p>
<p>一般在开发过程中，我们有两个角色：</p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq02.png"></p>
<p><strong>相关依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--amqp协议的起步依赖坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>相关配置</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq主机地址和端口号</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户和密码</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">wuxie</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置虚拟主机，作用把消息队列进行权限划分，不同部门拥有同一个消息队列的不同虚拟主机</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/amazingdl</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常见队列、交换机并绑定</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过Java代码创建交换机、消息队列，并绑定交换机与消息队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建消息队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个参数：消息队列名</span></span><br><span class="line"><span class="comment">         * 第二个参数：是否持久化</span></span><br><span class="line"><span class="comment">         * 第三个参数：是否独占</span></span><br><span class="line"><span class="comment">         * 第四个参数：是否自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;order.test&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建交换机，路由交换机，这里还有其他类型的交换机，不同的工作模式有不同交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">orderExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个参数：交换机名成</span></span><br><span class="line"><span class="comment">         * 第二个参数：是否持久化</span></span><br><span class="line"><span class="comment">         * 第三个参数：是否自动删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;order_test_exchange&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机与消息队列的绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">exchangeBindingQueue</span><span class="params">(Queue orderQueue,DirectExchange orderExchange)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//BindingBuilder.bind(队列对象).to(交换机对象).with(路由键)</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(orderQueue).to(orderExchange).with(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、消息队列的五种工作模式"><a href="#三、消息队列的五种工作模式" class="headerlink" title="三、消息队列的五种工作模式"></a>三、消息队列的五种工作模式</h2><h3 id="3-1-简单模式"><a href="#3-1-简单模式" class="headerlink" title="3.1 简单模式"></a>3.1 简单模式</h3><blockquote>
<p>什么是简单模式</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq03.png"></p>
<p>在上图的模型中，有以下概念：</p>
<p>**P：生产者: **  也就是要发送消息的程序</p>
<p><strong>C：消费者：</strong>消息的接受者，会一直等待消息到来。</p>
<p><strong>queue：</strong>消息队列，图中红色部分。可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</p>
<blockquote>
<p>创建simple_queue消息队列，可通过图形化界面操作，也可通过Java代码</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq04.png"></p>
<blockquote>
<p>生产者发送消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数一：消息队列的名称</span></span><br><span class="line"><span class="comment">         * 参数二：消息队列的内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple_queue&quot;</span>,<span class="string">&quot;你好，这是消息队列提供者!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>消费者接收消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单模式下的监听者，监听队列中是否有消息，如果有消息，触发接收方法，打印消息</span></span><br><span class="line"><span class="comment"> * 注入Spring容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple_queue&quot;)</span><span class="comment">//当前监听器的监听队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleConsumerListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleConsumerHandler</span><span class="params">(String msg)</span></span>&#123;<span class="comment">//参数为消息的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;监听的内容：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-工作队列模式"><a href="#3-2-工作队列模式" class="headerlink" title="3.2 工作队列模式"></a>3.2 工作队列模式</h3><p>Work Queues与入门程序的简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。<strong>应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。</strong></p>
<p><strong>在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是竞争的关系。</strong></p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq05.png"></p>
<blockquote>
<p>创建work_queue队列</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq06.png"></p>
<blockquote>
<p>生产者发送消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工作模式消息队列，一个生产者，多个消费者竞争消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;work_queue&quot;</span>,<span class="string">&quot;这是第&quot;</span>+i+<span class="string">&quot;条消息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>消费者接收消</p>
</blockquote>
<p>第一个消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work_queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumerListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听消息的回调方法，处理监听消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgHandler</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;msgHandler【1】接收到的消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work_queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumerListener2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgHandler2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;msgHandler【2】接收到的消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-发布、订阅模式"><a href="#3-3-发布、订阅模式" class="headerlink" title="3.3 发布、订阅模式"></a>3.3 发布、订阅模式</h3><p>发布订阅模式： </p>
<p>​    1、每个消费者监听自己的队列。 </p>
<p>​    2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息</p>
<p>【广播消息：一次性将消息发送给所有消费者，每个消费者收到消息均一致】</p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq07.png"></p>
<blockquote>
<p>创建两个队列</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq08.png"></p>
<blockquote>
<p>创建交换机</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq09.png"></p>
<blockquote>
<p>绑定交换机</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq10.png"></p>
<blockquote>
<p>生产者发送消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发布订阅模式</span></span><br><span class="line"><span class="comment"> * 一个生产者，多个消费者，每个消费者接收的内容相同，发布订阅模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数一：设置交换机</span></span><br><span class="line"><span class="comment">     * 参数二：设置路由键，广播模式默认不设置路由键，为空字符串</span></span><br><span class="line"><span class="comment">     * 参数三：设置消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;fanout_exchange&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;你好，这是广播模式发布者&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>消费者接收消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发布订阅模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout_queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumerListener1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听消息的回调方法，处理监听消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgHandler</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;msgHandler【1】接收到的消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout_queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumerListener2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听消息的回调方法，处理监听消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgHandler</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;msgHandler【2】接收到的消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-路由模式"><a href="#3-4-路由模式" class="headerlink" title="3.4 路由模式"></a>3.4 路由模式</h3><p>路由模式特点：</p>
<p>队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）消息的发送方在向 Exchange发送消息时，也必须指定消息的RoutingKey。Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的Routing key完全一致，才会接收到消息。</p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq11.png"></p>
<p>图解：</p>
<p>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p>
<p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给与routing key完全匹配的队列</p>
<p>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</p>
<p>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p>
<p>【有选择性的接收消息】</p>
<blockquote>
<p>创建routing_queue1和routing_queue2队列</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq12.png"></p>
<blockquote>
<p>创建交换机routing_exchange</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq13.png"></p>
<blockquote>
<p>绑定消息队列</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq14.png"></p>
<blockquote>
<p>生产者发送消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由模式</span></span><br><span class="line"><span class="comment"> * 一个生产者，多个消费者，每个消费者通过路由键指定接收消息的队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数一：设置交换机</span></span><br><span class="line"><span class="comment">     * 参数二：设置路由键，广播模式默认不设置路由键，为空字符串</span></span><br><span class="line"><span class="comment">     * 参数三：设置消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;routing_exchange&quot;</span>,<span class="string">&quot;info&quot;</span>,<span class="string">&quot;你好，这是路由模式发布者，info信息&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;routing_exchange&quot;</span>,<span class="string">&quot;error&quot;</span>,<span class="string">&quot;你好，这是路由模式发布者，error信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>消费者接收消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发布订阅模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;routing_queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingConsumerListener1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听消息的回调方法，处理监听消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgHandler</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;msgHandler【1】接收到的消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;routing_queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingConsumerListener2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听消息的回调方法，处理监听消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgHandler</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;msgHandler【2】接收到的消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据路由键，交换机将消息发送到不同的队列，然后每个队列对应的消费者去消费。</p>
<h3 id="3-5-通配符模式"><a href="#3-5-通配符模式" class="headerlink" title="3.5 通配符模式"></a>3.5 通配符模式</h3><p><code>Topic</code>类型与<code>Direct</code>相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key的时候使用通配符！</p>
<p><code>Routingkey</code>: 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如：<code>item.insert</code></p>
<p>通配符规则：</p>
<p>#：匹配一个或多个词，多个词用点号分隔</p>
<p>*：匹配不多不少恰好1个词</p>
<p>举例：</p>
<p><strong>item.#：</strong> 能够匹配<code>item.insert.abc.bbc</code>或者<code>item.insert</code></p>
<p>*<em>item.<em>：</em></em>只能匹配<code>item.insert</code></p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq15.png"></p>
<blockquote>
<p>创建队列topic_queue1和topic_queue2</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq16.png"></p>
<blockquote>
<p>创建交换机</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq17.png"></p>
<blockquote>
<p>绑定消息队列</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq18.png"></p>
<blockquote>
<p>生产者发送消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通配符模式</span></span><br><span class="line"><span class="comment"> * 一个生产者，多个消费者，每个消费者通过路由键指定接收消息的队列，路由键是有通配符规定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数一：设置交换机</span></span><br><span class="line"><span class="comment">     * 参数二：设置路由键，广播模式默认不设置路由键，为空字符串</span></span><br><span class="line"><span class="comment">     * 参数三：设置消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;topic_exchange&quot;</span>,<span class="string">&quot;item.insert.abc&quot;</span>,<span class="string">&quot;你好，这是路由模式发布者，item.*接收信息&quot;</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;topic_exchange&quot;</span>,<span class="string">&quot;item.insert&quot;</span>,<span class="string">&quot;你好，这是路由模式发布者，item.#接收信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>消费者接收消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发布订阅模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic_queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumerListener1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听消息的回调方法，处理监听消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgHandler</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;msgHandler【1】接收到的消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic_queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumerListener2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听消息的回调方法，处理监听消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgHandler</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;msgHandler【2】接收到的消息：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据路由通配符的匹配规则，不同的消息会进入不同的队列，然后由绑定该队列的消费者接收。</p>
<h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h3><p>工作模式：</p>
<p>**1、简单模式 HelloWorld : ** 一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）</p>
<p><strong>2、工作队列模式 Work Queue:</strong>  一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）</p>
<p><strong>3、发布订阅模式 Publish/subscribe: **需要设置类型为</strong>==fanout==**的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息广播发送到绑定的队列</p>
<p><strong>4、路由模式 Routing: ** 需要设置类型为</strong>==direct==**的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p>
<p><strong>5、通配符模式 Topic: ** 需要设置类型为==**topic</strong>==的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p>
<h2 id="四、消息队列的高级特性"><a href="#四、消息队列的高级特性" class="headerlink" title="四、消息队列的高级特性"></a>四、消息队列的高级特性</h2><h3 id="4-1-生产者确认"><a href="#4-1-生产者确认" class="headerlink" title="4.1 生产者确认"></a>4.1 生产者确认</h3><p>在生产者向消息队列发送消息时，由于各种原因，可能会导致生产者向消息队列发送消息失败。</p>
<p>比如：</p>
<ul>
<li>第一，生产者发送消息给MQ失败，消息丢失；</li>
<li>第二，交换机路由到队列失败，路由键写错；</li>
</ul>
<p>在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式。</p>
<ul>
<li><p>confirm 确认模式</p>
</li>
<li><p>return  退回模式</p>
</li>
</ul>
<p>rabbitmq 整个消息投递的路径为：</p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq19.png"></p>
<ul>
<li><p>消息从生产者(producer)发送消息到交换机(exchange)，不论是否成功，都会执行一个确认回调方法confirmCallback 。</p>
</li>
<li><p>消息从交换机(exchange)到消息队列( queue )投递失败则会执行一个返回回调方法 returnCallback 。</p>
</li>
</ul>
<p>我们将利用这两个 callback 控制消息的可靠性投递</p>
<blockquote>
<p>确认模式</p>
</blockquote>
<p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置文件</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当然这里也包含了一些其他相关的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启生产者确认模式：(confirm),投递到交换机，不论失败或者成功都回调</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在2.2.0及之后该属性过期使用spring.rabbitmq.publisher-confirm-type属性配置代替</span></span><br><span class="line"><span class="comment"># 选择确认类型为交互</span></span><br><span class="line"><span class="comment"># NONE值是禁用发布确认模式，是默认值</span></span><br><span class="line"><span class="comment"># CORRELATED值是发布消息成功到交换器后会触发回调方法，如1示例</span></span><br><span class="line"><span class="comment"># SIMPLE值经测试有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果返回false则会关闭channel，则接下来无法发送消息到broker;</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure>

<p><strong>确认回调类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者发送消息回调类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConfirmCallback</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前类的对象创建完之后，执行的方法，post代表后，pre代表前</span></span><br><span class="line"><span class="comment">     * 然后将当前对象设置给rabbitTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置确认回调方法</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>::confirm);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确认回调方法，为了确定消息进入了交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 封装消息相关的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack 消息是否发送成功，true代表发送成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 失败的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息成功进入了交互机&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息失败，消息原因：&quot;</span>+cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送消息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向消息队列发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/direct/sendMsg&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMsg</span><span class="params">(String exchange,String routingKey,String msg)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange,routingKey,msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息已投递&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的消费者接收消息与前面相同</p>
<blockquote>
<p>回退模式</p>
</blockquote>
<p><strong>配置文件</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启消息回退模式</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p><strong>回调类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者发送消息回调类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConfirmCallback</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>,<span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前类的对象创建完之后，执行的方法，post代表后，pre代表前</span></span><br><span class="line"><span class="comment">     * 然后将当前对象设置给rabbitTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置确认回调方法</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>::confirm);</span><br><span class="line">        <span class="comment">//设置回退回调方法</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>::returnedMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确认回调方法，为了确定消息进入了交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 封装消息相关的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack 消息是否发送成功，true代表发送成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 失败的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息成功进入了交互机&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息失败，消息原因：&quot;</span>+cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调回调方法，为了确定消息进入了队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 发送的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyCode 错误状态码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyText 错误原因</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 交换机名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey 路由名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息失败，交互机路由队列错误&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息：&quot;</span>+message);</span><br><span class="line">        System.out.println(<span class="string">&quot;错误状态码：&quot;</span>+replyCode);</span><br><span class="line">        System.out.println(<span class="string">&quot;错误信息：&quot;</span>+replyText);</span><br><span class="line">        System.out.println(<span class="string">&quot;交互机：&quot;</span>+exchange);</span><br><span class="line">        System.out.println(<span class="string">&quot;路由键：&quot;</span>+routingKey);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时发送消息与接收消息与确认模式相同。</p>
<p>说明：</p>
<p>确认模式：</p>
<ul>
<li>设置publisher-confirms=”true”或 spring.rabbitmq.publisher-confirm-type=correlated 开启 确认模式。</li>
<li>实现RabbitTemplate.ConfirmCallback接口，重写confirm方法</li>
<li>特点：不论消息是否成功投递至交换机，都回调confirm方法，只有在发送失败时需要写业务代码进行处理。</li>
</ul>
<p>退回模式</p>
<ul>
<li>设置publisher-returns=”true” 开启 退回模式。</li>
<li>实现RabbitTemplate.ReturnCallback接口，重写returnedMessage方法</li>
<li>特点：消息进入交换机后，只有当从exchange路由到queue失败，才去回调returnedMessage方法；</li>
</ul>
<h3 id="4-2-消费者确认"><a href="#4-2-消费者确认" class="headerlink" title="4.2 消费者确认"></a>4.2 消费者确认</h3><p>为了达到消费者能百分百接收到请求，且业务执行过程中还不能出错！需要消费者手动确认。</p>
<p>ack指 <strong>Acknowledge</strong>，拥有确认的含义，是消费端收到消息的一种确认机制；</p>
<p>消息确认的三种类型：</p>
<ul>
<li><p>自动确认：acknowledge=”<strong>none</strong>“</p>
</li>
<li><p>手动确认：acknowledge=”<strong>manual</strong>“</p>
</li>
<li><p>根据异常情况确认：acknowledge=”<strong>auto</strong>“，（这种方式使用麻烦，不作讲解）</p>
</li>
</ul>
<p>其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。</p>
<p>如果设置了手动确认方式，则需要在业务处理成功后，调用<code>channel.basicAck()</code>，手动签收，如果出现异常，则调用<code>channel.basicNack()</code>方法，让其自动重新发送消息。</p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq19.png"></p>
<p>自定义监听器涉及三个对象：三个对象必须注入Spring容器</p>
<ol>
<li>自定义监听器对象</li>
<li>自定义监听器的适配器Adaptor对象</li>
<li>监听器的容器对象</li>
</ol>
<blockquote>
<p>创建自定义监听器类CustomAckConsumerListener，实现ChannelAwareMessageListener接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义监听器，用于接收消息队列order.A发送的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAckConsumerListener</span> <span class="keyword">implements</span> <span class="title">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义监听器的监听方法，作用：监听消息队列发送过来的消息，然后执行当前方法</span></span><br><span class="line"><span class="comment">     * 监听器三要素：</span></span><br><span class="line"><span class="comment">     *      监听对象：消息队列</span></span><br><span class="line"><span class="comment">     *      事件源：消息</span></span><br><span class="line"><span class="comment">     *      执行操作：执行的操作onMessage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 频道，就是在生产者、消费者与消息队列的连接中包含多个channel，详见消息队列结构图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1、获取消息队列中的消息</span></span><br><span class="line">        String messageBody = <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取投递标签</span></span><br><span class="line">        MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> deliveryTag = messageProperties.getDeliveryTag();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//2、执行业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;执行正常的逻辑，消息的内容：&quot;</span>+messageBody);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模拟异常情况</span></span><br><span class="line"><span class="comment">//            if(messageBody.contains(&quot;苹果&quot;))&#123;</span></span><br><span class="line"><span class="comment">//                throw new RuntimeException(&quot;苹果手机不能卖&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//可通过休眠，延时消费端限流的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3、正常，签收消息</span></span><br><span class="line">            <span class="comment">//第一个参数：投递标签</span></span><br><span class="line">            <span class="comment">//第二个参数：是否是批量签收，如果是true，将当前队列对应链接中的所有消息一次签收，false只签收当前消息</span></span><br><span class="line">            channel.basicAck(deliveryTag,<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;手动签收&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//4、异常拒签消息，消息重回消息队列</span></span><br><span class="line">            <span class="comment">//第三个参数：是否从回队列</span></span><br><span class="line">            System.out.println(<span class="string">&quot;手动拒签，原因：&quot;</span>+e.getMessage());</span><br><span class="line">            channel.basicNack(deliveryTag,<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编写监听器配置类ListenerConfiguration，配置自定义监听器绑定消息队列<code>order.A</code>并配置适配器实体类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义监听器的适配器对象，在配置类中@Bean的方法可直接自动注入Spring容器的对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageListenerAdapter <span class="title">messageListenerAdapter</span><span class="params">(CustomAckConsumerListener listener)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageListenerAdapter(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听器容器对象</span></span><br><span class="line"><span class="comment">     * 设置链接工厂对象，链接放的是channel, ConnectionFactory 连接工厂</span></span><br><span class="line"><span class="comment">     * 设置自定义监听对象的适配器对象 MessageListenerAdapter</span></span><br><span class="line"><span class="comment">     * 设置绑定的消息对象 order.A</span></span><br><span class="line"><span class="comment">     * 设置手动签收模式 ackKnowledgeMode 手动签收 MANUAL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">simpleMessageListenerContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            MessageListenerAdapter messageListenerAdapter,</span></span></span><br><span class="line"><span class="function"><span class="params">            ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置自定义监听对象的适配器对象</span></span><br><span class="line">        container.setMessageListener(messageListenerAdapter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置链接工厂对象</span></span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定当前消息队列</span></span><br><span class="line">        container.setQueueNames(<span class="string">&quot;order.A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置手动签收模式,MANUAL-手动签收；NONE-自动签收；AUTO-出现异常签收</span></span><br><span class="line">        container.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置消费端限流，限制每次只拉去一条消息，默认每次拉去250条</span></span><br><span class="line">        container.setPrefetchCount(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>如果想手动签收消息，那么需要自定义实现消息接收监听器，实现ChannelAwareMessageListener接口</li>
<li>设置AcknowledgeMode模式<ul>
<li>none：自动</li>
<li>auto：异常模式</li>
<li>manual：手动</li>
</ul>
</li>
<li>调用channel.basicAck方法签收消息</li>
<li>调用channel.basicNAck方法拒签消息</li>
</ul>
<h3 id="4-3-消费端限流"><a href="#4-3-消费端限流" class="headerlink" title="4.3 消费端限流"></a>4.3 消费端限流</h3><p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq20.png"></p>
<p>如上图所示：</p>
<p><strong>第一种情况：</strong></p>
<ul>
<li>如果在A系统中需要维护相关的业务功能，可能需要将A系统的服务停止，那么这个时候消息的生产者还是一直会向MQ中发送待处理的消息，消费者此时服务已经关闭，导致大量的消息都会在MQ中累积。</li>
<li>如果当A系统成功启动后，消费者会一次性将MQ中累积的大量的消息拉取到自己的服务，导致服务在短时间内会处理大量的业务，可能会导致系统服务的崩溃。 所以消费端限流是非常有必要的。</li>
</ul>
<p><strong>第二种情况：</strong>当大量用户注册时，高并发请求过来，邮件接口只支持小量并发，这时消费端限流也非常必要；</p>
<p>消费端限流配置：设置监听器容器属性container.setPrefetchCount(1)；表示消费端每次从mq拉去1条消息来消费，直到手动确认消费完毕后，才会继续拉去下一条消息。</p>
<p>实现步骤：</p>
<p>在自定义消息监听器配置类ListenerConfiguration类中，配置每次拉取消息1条<code>container.setPrefetchCount(1);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注入消息监听器容器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connectionFactory 连接工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> messageListenerAdapter 自定义的消息监听器适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">simpleMessageListenerContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConnectionFactory connectionFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        MessageListenerAdapter messageListenerAdapter)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单的消息监听器容器对象</span></span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    <span class="comment">//绑定消息队列</span></span><br><span class="line">    container.setQueueNames(<span class="string">&quot;order.A&quot;</span>);</span><br><span class="line">    <span class="comment">//设置连接工厂对象</span></span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    <span class="comment">//设置消息监听器适配器</span></span><br><span class="line">    container.setMessageListener(messageListenerAdapter);</span><br><span class="line">    <span class="comment">//设置手动确认消息：NONE(不确认消息)，MANUAL(手动确认消息)，AUTO(自动确认消息)</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置消费端限流，每次拉取消息多少条，默认是250条</span></span><br><span class="line">    container.setPrefetchCount(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明</p>
<ul>
<li>消费端自定义消息监听器绑定消息队列时，设置每次拉取消息1条setPrefetchCount(1);</li>
<li>注意，如果想进行消费端限流，那么消息必须手动确认，AcknowledgeMode为MANUAL</li>
</ul>
<h3 id="4-4-TTL"><a href="#4-4-TTL" class="headerlink" title="4.4 TTL"></a>4.4 TTL</h3><p>TTL 全称 Time To Live（存活时间/过期时间）。当消息到达存活时间后，还没有被消费，会被自动清除。</p>
<p>RabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间。</p>
<p><strong>注意：给单个消息设置过期时间没实际意义。</strong></p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq21.png"></p>
<p>在RabbitMQ管理控制台中，新增消息队列<code>order</code>，并设置消息失效时间为5秒</p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq22.png"></p>
<p>也可在发送消息时，设置过期时间</p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq23.png"></p>
<p>说明：</p>
<ul>
<li>设置队列过期时间使用参数：x-message-ttl，单位：ms(毫秒)，会对整个队列消息统一过期。</li>
<li>由于队列是先进先出的，所以如果设置单个消息的过期时间并没有实际意义<ul>
<li>例如：设置消息A的过期时间为10秒，消息B的过期时间为5秒，但是先将消息A发送至队列，那么只有等消息A被消费或者到期移除后才会将消息B消费或者到期移除。</li>
</ul>
</li>
</ul>
<h3 id="4-5-死信队列"><a href="#4-5-死信队列" class="headerlink" title="4.5 死信队列"></a>4.5 死信队列</h3><p>死信队列：当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是Dead Letter Exchange（死信交换机 简写：DLX）。</p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq24.png"></p>
<p><strong>消息成为死信的三种情况：</strong></p>
<ol>
<li><p>队列消息长度到达限制；</p>
</li>
<li><p>消费者拒接消息(basicNack)，并且不把消息重新放回源队列，requeue=false；</p>
</li>
<li><p>源队列存在消息过期设置，消息到达超时时间未被消费；</p>
</li>
</ol>
<p><strong>设置死信队列绑定死信交换机：</strong></p>
<p>给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key</p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq25.png"></p>
<p><strong>案例目标</strong>：演示消息队列中消息超时失效</p>
<blockquote>
<p>实现步骤：</p>
</blockquote>
<ol>
<li><p>在RabbitMQ管理控制台中，创建死信队列<code>deadQueue</code></p>
</li>
<li><p>在RabbitMQ管理控制台中，创建死信交换机<code>deadExchange</code></p>
</li>
<li><p>死信队列绑定死信交换机，路由键为<code>order.dead</code></p>
</li>
<li><p>消息队列order.B绑定死信交换机</p>
</li>
<li><p>向消息队列<code>order.B</code>中发送消息【消息队列order.B中的消息失效时间为5秒】</p>
</li>
<li><p>在RabbitMQ管理控制台中，将消息队列<code>order.B</code>绑定到交换机<code>order_exchange</code>上</p>
</li>
<li><p>等待5秒，消息队列order.B中的消息进入死信队列</p>
</li>
</ol>
<blockquote>
<p>创建deadqueue</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq26.png"></p>
<blockquote>
<p>创建deadExchange</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq27.png"></p>
<blockquote>
<p>死信队列绑定死信交换机，路由键为dead</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq28.png"></p>
<blockquote>
<p>创建队列order.B，并绑定死信交换机</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq29.png"></p>
<blockquote>
<p>队列order.B绑定交换机并发送消息</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq30.png"></p>
<blockquote>
<p>结果</p>
</blockquote>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq31.png"></p>
<p>说明：</p>
<ol>
<li><p>死信交换机和死信队列和普通的没有区别</p>
</li>
<li><p>当消息成为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列</p>
</li>
<li><p>消息成为死信的三种情况：</p>
<ul>
<li><p>队列消息长度到达限制；</p>
</li>
<li><p>消费者拒接消费消息，并且不重回队列；</p>
</li>
<li><p>原队列存在消息过期设置，消息到达超时时间未被消费；</p>
</li>
</ul>
</li>
</ol>
<h3 id="4-6-延迟队列"><a href="#4-6-延迟队列" class="headerlink" title="4.6 延迟队列"></a>4.6 延迟队列</h3><p><strong>什么是延迟队列？即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费。</strong></p>
<p>需求场景：</p>
<ol>
<li>下单后，30分钟未支付，取消订单，回滚车票。</li>
<li>新用户注册成功7天后，发送短信问好。</li>
</ol>
<p>实现方法：</p>
<ol>
<li>定时器</li>
<li>延迟队列</li>
</ol>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq32.png"></p>
<p>注意：在RabbitMQ中并未提供延迟队列功能。</p>
<p>但是可以使用：<strong>TTL+死信队列</strong> 组合实现延迟队列的效果。</p>
<p><img src="/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/rabbitmq33.png"></p>
<h2 id="五、结束语"><a href="#五、结束语" class="headerlink" title="五、结束语"></a>五、结束语</h2><p>通过上面的学习，能够在项目中简单的使用消息队列。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/" title="消息队列之RabbitMQ的简单还是用" target="_blank" rel="external">https://amazingdl.github.io/2020/11/01/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/RabbitMQ/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/cofess" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/cofess" target="_blank"><span class="text-dark">AmazingDL</span><small class="ml-1x">Life Explorer</small></a></h3>
        <div>前路漫漫，我将独自前行</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2020/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构(三)——二叉树"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2020/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="数据结构(二)——栈和队列"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/AmazingDL" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://gitee.com/dl_wuxie" target="_blank" title="Gitee" data-toggle=tooltip data-placement=top><i class="icon icon-gitee"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>